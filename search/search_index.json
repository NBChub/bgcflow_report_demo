{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>mq_saccharopolyspora</code>","text":"<p>Summary report for project <code>mq_saccharopolyspora</code>. Generated using <code>BGCFlow v0.9.0</code></p>"},{"location":"#project-description","title":"Project Description","text":"<ul> <li>26 Saccharopolysopra genomes of medium to high quality with less than 50 contigs. The new cutoff now removes GCF_000710755.1, GCF_015209505.1, GCF_014646075.1 and adds GCF_014697215.1</li> <li>Sample size 26</li> </ul>"},{"location":"#available-reports","title":"Available reports","text":"BGCFlow_rules description seqfu Calculate sequence statistics using SeqFu. mash Calculate distance estimation for all samples using MinHash. fastani Do pairwise Average Nucleotide Identity (ANI) calculation across all samples. checkm Assess genome quality with CheckM. prokka-gbk Copy annotated genbank results. antismash Summarizes antiSMASH result. query-bigslice Map BGCs to BiG-FAM database (https://bigfam.bioinformatics.nl/) bigscape Cluster BGCs using BiG-SCAPE bigslice Cluster BGCs using BiG-SLiCE (https://github.com/medema-group/bigslice) automlst-wrapper Simplified Tree building using autoMLST arts Run Antibiotic Resistant Target Seeker (ARTS) on samples. roary Build pangenome using Roary. eggnog-roary Annotate Roary output using eggNOG mapper deeptfactor Use deep learning to find Transcription Factors. cblaster-genome Build diamond database of genomes for cblaster search. cblaster-bgc Build diamond database of BGCs for cblaster search. gecco GEne Cluster prediction with COnditional random fields."},{"location":"#references","title":"References","text":"<p>If you find BGCFlow useful, please cite:</p> <p> <ul> <li> <p>Nuhamunada, M., B.O. Palsson, O. S. Mohite, and T. Weber. 2022. BGCFlow [Computer software]. GITHUB: https://github.com/NBChub/bgcflow</p> </li> <li> <p>M\u00f6lder, F., Jablonski, K.P., Letcher, B., Hall, M.B., Tomkins-Tinch, C.H., Sochat, V., Forster, J., Lee, S., Twardziok, S.O., Kanitz, A., Wilm, A., Holtgrewe, M., Rahmann, S., Nahnsen, S., K\u00f6ster, J., 2021. Sustainable data analysis with Snakemake. F1000Res 10, 33.</p> </li> <li> <p>Nathan C Sheffield, Micha\u0142 Stolarczyk, Vincent P Reuter, Andr\u00e9 F Rendeiro, Linking big biomedical datasets to modular analysis with Portable Encapsulated Projects, GigaScience, Volume 10, Issue 12, December 2021, giab077</p> </li> </ul> <p></p> <p>Please also cite each tools used in the analysis:</p> <p> <ul> <li> <p>Gilchrist, C., Booth, T. J., van Wersch, B., van Grieken, L., Medema, M. H., &amp; Chooi, Y. (2021). cblaster: a remote search tool for rapid identification and visualisation of homologous gene clusters (Version 1.3.9) [Computer software]. https://doi.org/10.1101/2020.11.08.370601</p> </li> <li> <p>Andrew J. Page, Carla A. Cummins, Martin Hunt, Vanessa K. Wong, Sandra Reuter, Matthew T. G. Holden, Maria Fookes, Daniel Falush, Jacqueline A. Keane, Julian Parkhill, 'Roary: Rapid large-scale prokaryote pan genome analysis', Bioinformatics, 2015;31(22):3691-3693 doi:10.1093/bioinformatics/btv421</p> </li> <li> <p>Parks DH, Imelfort M, Skennerton CT, Hugenholtz P, Tyson GW. 2014. Assessing the quality of microbial genomes recovered from isolates, single cells, and metagenomes. Genome Research, 25: 1043-1055.</p> </li> <li> <p>Mungan,M.D., Alanjary,M., Blin,K., Weber,T., Medema,M.H. and Ziemert,N. (2020) ARTS 2.0: feature updates and expansion of the Antibiotic Resistant Target Seeker for comparative genome mining. Nucleic Acids Res.,10.1093/nar/gkaa374</p> </li> <li> <p>Buchfink, B., Xie, C. &amp; Huson, D. H. Fast and sensitive protein alignment using DIAMOND. Nat. Methods 12, 59\u201360 (2015).</p> </li> <li> <p>Accurate de novo identification of biosynthetic gene clusters with GECCO. Laura M Carroll, Martin Larralde, Jonas Simon Fleck, Ruby Ponnudurai, Alessio Milanese, Elisa Cappio Barazzone, Georg Zeller. bioRxiv 2021.05.03.442509; doi:10.1101/2021.05.03.442509</p> </li> <li> <p>Kim G.B., Gao Y., Palsson B.O., Lee S.Y. 2020. DeepTFactor: A deep learning-based tool for the prediction of transcription factors. PNAS. doi: 10.1073/pnas.2021171118</p> </li> <li> <p>Telatin, A., Birolo, G., &amp; Fariselli, P. SeqFu [Computer software]. GITHUB: https://github.com/telatin/seqfu2</p> </li> <li> <p>Navarro-Mu\u00f1oz, J.C., Selem-Mojica, N., Mullowney, M.W. et al. A computational framework to explore large-scale biosynthetic diversity. Nat Chem Biol 16, 60\u201368 (2020)</p> </li> <li> <p>antiSMASH 7.0: new and improved predictions for detection, regulation, chemical structures and visualisation. Kai Blin, Simon Shaw, Hannah E Augustijn, Zachary L Reitz, Friederike Biermann, Mohammad Alanjary, Artem Fetter, Barbara R Terlouw, William W Metcalf, Eric J N Helfrich, Gilles P van Wezel, Marnix H Medema, Tilmann Weber. Nucleic Acids Research (2023) doi: 10.1093/nar/gkad344</p> </li> <li> <p>Mash: fast genome and metagenome distance estimation using MinHash. Ondov BD, Treangen TJ, Melsted P, Mallonee AB, Bergman NH, Koren S, Phillippy AM. Genome Biol. 2016 Jun 20;17(1):132. doi: 10.1186/s13059-016-0997-x.</p> </li> <li> <p>Satria A Kautsar, Justin J J van der Hooft, Dick de Ridder, Marnix H Medema, BiG-SLiCE: A highly scalable tool maps the diversity of 1.2 million biosynthetic gene clusters, GigaScience, Volume 10, Issue 1, January 2021, giaa154</p> </li> <li> <p>Mohammad Alanjary, Katharina Steinke, Nadine Ziemert, AutoMLST: an automated web server for generating multi-locus species trees highlighting natural product potential,Nucleic Acids Research, Volume 47, Issue W1, 02 July 2019, Pages W276\u2013W282</p> </li> <li> <p>Satria A Kautsar, Justin J J van der Hooft, Dick de Ridder, Marnix H Medema, BiG-SLiCE: A highly scalable tool maps the diversity of 1.2 million biosynthetic gene clusters, GigaScience, Volume 10, Issue 1, January 2021, giaa154.</p> </li> <li> <p>Satria A Kautsar, Kai Blin, Simon Shaw, Tilmann Weber, Marnix H Medema, BiG-FAM: the biosynthetic gene cluster families database, Nucleic Acids Research, gkaa812, https://doi.org/10.1093/nar/gkaa812</p> </li> <li> <p>Alanjary,M., Kronmiller,B., Adamek,M., Blin,K., Weber,T., Huson,D., Philmus,B. and Ziemert,N. (2017) The Antibiotic Resistant Target Seeker (ARTS), an exploration engine for antibiotic cluster prioritization and novel drug target discovery. Nucleic Acids Res.,10.1093/nar/gkx360</p> </li> <li> <p>eggNOG-mapper v2: functional annotation, orthology assignments, and domain prediction at the metagenomic scale. Carlos P. Cantalapiedra, Ana Hernandez-Plaza, Ivica Letunic, Peer Bork, Jaime Huerta-Cepas. 2021. Molecular Biology and Evolution, msab293</p> </li> <li> <p>eggNOG 5.0: a hierarchical, functionally and phylogenetically annotated orthology resource based on 5090 organisms and 2502 viruses. Jaime Huerta-Cepas, Damian Szklarczyk, Davide Heller, Ana Hern\u00e1ndez-Plaza, Sofia K Forslund, Helen Cook, Daniel R Mende, Ivica Letunic, Thomas Rattei, Lars J Jensen, Christian von Mering, Peer Bork Nucleic Acids Res. 2019 Jan 8; 47(Database issue): D309\u2013D314. doi: 10.1093/nar/gky1085</p> </li> <li> <p>Mash Screen: high-throughput sequence containment estimation for genome discovery. Ondov BD, Starrett GJ, Sappington A, Kostic A, Koren S, Buck CB, Phillippy AM. Genome Biol. 2019 Nov 5;20(1):232. doi: 10.1186/s13059-019-1841-x.</p> </li> <li> <p>Seemann T. Prokka: rapid prokaryotic genome annotation. Bioinformatics 2014 Jul 15;30(14):2068-9. PMID:24642063</p> </li> <li> <p>Jain, C., Rodriguez-R, L.M., Phillippy, A.M. et al. High throughput ANI analysis of 90K prokaryotic genomes reveals clear species boundaries. Nat Commun 9, 5114 (2018). https://doi.org/10.1038/s41467-018-07641-9</p> </li> <li> <p>antiSMASH 6.0: improving cluster detection and comparison capabilities. Kai Blin, Simon Shaw, Alexander M Kloosterman, Zach Charlop-Powers, Gilles P van Weezel, Marnix H Medema, &amp; Tilmann Weber. Nucleic Acids Research (2021) doi: 10.1093/nar/gkab335.</p> </li> </ul> <p></p>"},{"location":"antismash/","title":"antiSMASH","text":"<p>Note: Here the incomplete BGCs are denoted by those that were identified to be on the contig edge by antiSMASH and thus are likely to be incomplete.</p> <p>Click on the BGC ids to go to the region's antiSMASH result.</p> <p>[Download Table]({{ project().file_server() }}/tables/df_regions_antismash_{{project().dependency_version()}}.csv){:target=\"_blank\" .md-button}</p>"},{"location":"antismash/#antismash","title":"antiSMASH\u00b6","text":"<p>Summary of BGCs detected in each genome for: <code>[{{ project().name }}]</code></p>"},{"location":"antismash/#description","title":"Description\u00b6","text":"<p>antiSMASH allows the rapid genome-wide identification, annotation and analysis of secondary metabolite biosynthesis gene clusters in bacterial and fungal genomes.</p>"},{"location":"antismash/#result-summary","title":"Result Summary\u00b6","text":""},{"location":"antismash/#summary-table","title":"Summary Table\u00b6","text":"<p>Click on the genome ids to get the antiSMASH result.</p> <p>[Download Table]({{ project().file_server() }}/tables/df_antismash_{{project().dependency_version()}}_summary.csv){:target=\"_blank\" .md-button}</p>"},{"location":"antismash/#regions-summary","title":"Regions Summary\u00b6","text":""},{"location":"antismash/#references","title":"References\u00b6","text":"{% for i in project().rule_used['antismash']['references'] %} - {{ i }}  {% endfor %}"},{"location":"antismash/","title":"antiSMASH","text":"<p>Summary of BGCs detected in each genome for: <code>[mq_saccharopolyspora]</code></p>"},{"location":"antismash/#description","title":"Description","text":"<p>antiSMASH allows the rapid genome-wide identification, annotation and analysis of secondary metabolite biosynthesis gene clusters in bacterial and fungal genomes.</p>"},{"location":"antismash/#result-summary","title":"Result Summary","text":"<p>AntiSMASH detected 739 BGCs from 26 genomes with the median of 26. Out of these, 94.05% are deemed as complete.</p> <p>Note: Here the incomplete BGCs are denoted by those that were identified to be on the contig edge by antiSMASH and thus are likely to be incomplete.</p>"},{"location":"antismash/#summary-table","title":"Summary Table","text":"<p>Click on the genome ids to get the antiSMASH result.</p> <p>Download Table</p> Genome ID GTDB genus GTDB species Strain BGCs Incomplete BGCs GCF_003635025.1 Saccharopolyspora Saccharopolyspora antimicrobica 0.0 26 0 GCF_900114905.1 Saccharopolyspora Saccharopolyspora antimicrobica 0.0 26 7 GCF_007829955.1 Saccharopolyspora Saccharopolyspora dendranthemae 0.0 22 0 GCF_018070075.1 Saccharopolyspora Saccharopolyspora endophytica 0.0 26 7 GCF_016859185.1 Saccharopolyspora_D Saccharopolyspora_D erythraea 0.0 38 0 GCF_018141105.1 Saccharopolyspora_D Saccharopolyspora_D erythraea_A 0.0 37 0 GCF_022392385.1 Saccharopolyspora_D Saccharopolyspora_D erythraea 0.0 37 1 GCF_000062885.1 Saccharopolyspora_D Saccharopolyspora_D erythraea 0.0 37 0 GCF_002564065.1 Saccharopolyspora_D Saccharopolyspora_D erythraea 0.0 38 0 GCF_900116135.1 Saccharopolyspora Saccharopolyspora flava 0.0 19 4 GCF_014203325.1 Saccharopolyspora_C Saccharopolyspora_C gloriosae 0.0 24 0 GCF_022828475.1 Saccharopolyspora_C Saccharopolyspora_C sp. 0.0 25 0 GCF_024734405.1 Saccharopolyspora_C Saccharopolyspora_C sp. 0.0 24 0 GCF_008630535.1 Saccharopolyspora Saccharopolyspora hirsuta 0.0 22 7 GCF_013410345.1 Saccharopolyspora Saccharopolyspora hordei 0.0 13 0 GCF_900112555.1 Saccharopolyspora Saccharopolyspora kobensis 0.0 24 4 GCF_900108315.1 Saccharopolyspora Saccharopolyspora kobensis 0.0 24 1 GCF_014203395.1 Saccharopolyspora Saccharopolyspora phatthalungensis 0.0 36 1 GCF_014697215.1 Saccharopolyspora Saccharopolyspora pogona 0.0 37 0 GCF_003931915.1 Saccharopolyspora Saccharopolyspora rhizosphaerae 0.0 14 2 GCF_025643595.1 Saccharopolyspora Saccharopolyspora sp. 0.0 19 0 GCF_012277335.1 Saccharopolyspora Saccharopolyspora pogona 0.0 32 0 GCF_016526145.1 Saccharopolyspora_C Saccharopolyspora_C sp016526145 0.0 26 7 GCF_014490055.1 Saccharopolyspora Saccharopolyspora spinosa 0.0 38 1 GCF_002846475.1 Saccharopolyspora Saccharopolyspora spinosa 0.0 38 0 GCF_000194155.1 Saccharopolyspora Saccharopolyspora spinosa 0.0 37 2"},{"location":"antismash/#regions-summary","title":"Regions Summary","text":"<ul> <li>KnownClusterBlast hits 135 out of 739 BGC regions with high similarity (&gt;80%) to MIBIG entries.</li> <li>Those entries includes: geosmin (31), ectoine (26), 2-methylisoborneol (15), Ery-9/Ery-6/Ery-8/Ery-7/Ery-5/Ery-4/Ery-3 (14), \u03b5-Poly-L-lysine (6), flaviolin/flaviolin rhamnoside/3,3'-diflaviolin (5), A83543A (5), erythrochelin (5), E-837 (5), erythromycin A/erythromycin B/erythromycin C/erythromycin D (5), coelibactin (4), antimycin (3), kyamicin (3), iso-migrastatin/migrastatin/dorrigocin A/dorrigocin B/13-epi-dorrigocin A (2), branched-chain fatty acids (1), ulleungdin (1), alkylresorcinol (1), SGR PTMs/SGR PTM Compound b/SGR PTM Compound c/SGR PTM Compound d (1), herboxidiene (1), LP2 (1).</li> <li>There are 131 BGC regions with medium similarity (&lt;80%) to MIBIG entries.</li> <li>There are 342 BGC regions with low similarity (&lt;40%) to MIBIG entries.</li> <li>There are also 131 BGC regions that does not have any hits to the MIBIG entries.</li> </ul> <p>Click on the BGC ids to go to the region's antiSMASH result.</p> <p>Download Table</p> BGC ID Genome ID region product Most Similar Known Cluster Similarity contig_edge Loading... (need help?)"},{"location":"antismash/#references","title":"References","text":"<p> <ul> <li> <p>antiSMASH 6.0: improving cluster detection and comparison capabilities. Kai Blin, Simon Shaw, Alexander M Kloosterman, Zach Charlop-Powers, Gilles P van Weezel, Marnix H Medema, &amp; Tilmann Weber. Nucleic Acids Research (2021) doi: 10.1093/nar/gkab335. </p> </li> <li> <p>antiSMASH 7.0: new and improved predictions for detection, regulation, chemical structures and visualisation. Kai Blin, Simon Shaw, Hannah E Augustijn, Zachary L Reitz, Friederike Biermann, Mohammad Alanjary, Artem Fetter, Barbara R Terlouw, William W Metcalf, Eric J N Helfrich, Gilles P van Wezel, Marnix H Medema, Tilmann Weber. Nucleic Acids Research (2023) doi: 10.1093/nar/gkad344 </p> </li> </ul> <p></p>"},{"location":"arts/","title":"ARTS2","text":"<p>Download Graph{:target=\"_blank\" .md-button}</p>"},{"location":"arts/#arts2","title":"ARTS2\u00b6","text":"<p>Summary of ARTS2 results from project: <code>[{{ project().name }}]</code></p>"},{"location":"arts/#description","title":"Description\u00b6","text":"<p>This report presents the results from ARTS2 (Antibiotic Resistant Target Seeker Version 2), a bioinformatic tool for targeted genome mining of antibiotic resistance targets. The analysis focused on identifying genes with signatures of antibiotic resistances, gene duplication, horizontal gene transfer, and proximity to biosynthetic gene cluster (BGC).</p> <p>Here, only ARTS2 profile with BGC proximity are shown.</p> <p>Table Description:</p> <ul> <li>Dup: Uncommon gene duplication. Highlight potential repurposed primary metabolism genes.</li> <li>Res: Hits to known resistance models.</li> <li>BGC: Cross reference locations or proximity to secondary metabolite BGCs.</li> <li>HGT: Phylogenetic incongruence. Highlight essential genes with evidence of inter-genus horizontal gene transfer (HGT).</li> </ul>"},{"location":"arts/#references","title":"References\u00b6","text":"{% for i in project().rule_used['arts']['references'] %} - {{ i }}  {% endfor %}"},{"location":"arts/","title":"ARTS2","text":"<p>Summary of ARTS2 results from project: <code>[mq_saccharopolyspora]</code> </p>"},{"location":"arts/#description","title":"Description","text":"<p>This report presents the results from ARTS2 (Antibiotic Resistant Target Seeker Version 2), a bioinformatic tool for targeted genome mining of antibiotic resistance targets. The analysis focused on identifying genes with signatures of antibiotic resistances, gene duplication, horizontal gene transfer, and proximity to biosynthetic gene cluster (BGC).</p> <p>Here, only ARTS2 profile with BGC proximity are shown.</p> <p>Table Description:</p> <ul> <li>Dup: Uncommon gene duplication. Highlight potential repurposed primary metabolism genes.</li> <li>Res: Hits to known resistance models.</li> <li>BGC: Cross reference locations or proximity to secondary metabolite BGCs.</li> <li>HGT: Phylogenetic incongruence. Highlight essential genes with evidence of inter-genus horizontal gene transfer (HGT).</li> </ul> index profile name product function hits Dup HGT Res BGC BGC ID Genome ID Loading... (need help?) <p>A total of 311 BGCs from 25 genomes were found to have hits with 133 ARTS2 profile.</p> <p>Download Graph</p>"},{"location":"arts/#references","title":"References","text":"<p> <ul> <li> <p>Mungan,M.D., Alanjary,M., Blin,K., Weber,T., Medema,M.H. and Ziemert,N. (2020) ARTS 2.0: feature updates and expansion of the Antibiotic Resistant Target Seeker for comparative genome mining. Nucleic Acids Res.,10.1093/nar/gkaa374 </p> </li> <li> <p>Alanjary,M., Kronmiller,B., Adamek,M., Blin,K., Weber,T., Huson,D., Philmus,B. and Ziemert,N. (2017) The Antibiotic Resistant Target Seeker (ARTS), an exploration engine for antibiotic cluster prioritization and novel drug target discovery. Nucleic Acids Res.,10.1093/nar/gkx360 </p> </li> </ul> <p></p>"},{"location":"automlst-wrapper/","title":"autoMLST Wrapper","text":"<p>Download Table{:target=\"_blank\" .md-button}</p>"},{"location":"automlst-wrapper/#automlst-wrapper","title":"autoMLST Wrapper\u00b6","text":"<p>Summary of autoMLST Wrapper results from project: <code>[{{ project().name }}]</code></p>"},{"location":"automlst-wrapper/#description","title":"Description\u00b6","text":"<p>This report provides an overview of the result from autoMLST Wrapper, a modified version of autoMLST tailored for simplified usability. By integrating a straightforward wrapper script, this fork eliminates the need for additional organism selection steps, streamlining the process for users.</p>"},{"location":"automlst-wrapper/#visualization","title":"Visualization\u00b6","text":"<p>The tree visualization represents the phylogenetic relationships between various strains of the genus. This visualization aids in understanding the genetic diversity and evolutionary history of these genomes.</p>"},{"location":"automlst-wrapper/#interactive-visualization-with-itol","title":"Interactive Visualization with iTOL\u00b6","text":"<p>For an enhanced, interactive visualization experience, users are encouraged to download the tree file and the corresponding annotation table. These files can be uploaded to iTOL (Interactive Tree Of Life), a web-based tool for the display, manipulation, and annotation of phylogenetic trees. Please check the iTOL help page for the upload guide and annotation format.</p>"},{"location":"automlst-wrapper/#references","title":"References\u00b6","text":"<ul> <li>Letunic I and Bork P (2021) Nucleic Acids Res doi: 10.1093/nar/gkab301 Interactive Tree Of Life (iTOL) v5: an online tool for phylogenetic tree display and annotation</li> <li>G Yu, DK Smith, H Zhu, Y Guan, TTY Lam<sup>*</sup>. ggtree: an R package for visualization and annotation of phylogenetic trees with their covariates and other associated data. Methods in Ecology and Evolution. 2017, 8(1):28-36. doi: 10.1111/2041-210X.12628</li> </ul> <p>{% for i in project().rule_used['automlst-wrapper']['references'] %}</p> <ul> <li>{{ i }} {% endfor %} </li></ul>"},{"location":"automlst-wrapper/","title":"autoMLST Wrapper","text":"<p>Summary of autoMLST Wrapper results from project: <code>[mq_saccharopolyspora]</code></p>"},{"location":"automlst-wrapper/#description","title":"Description","text":"<p>This report provides an overview of the result from autoMLST Wrapper, a modified version of autoMLST tailored for simplified usability. By integrating a straightforward wrapper script, this fork eliminates the need for additional organism selection steps, streamlining the process for users.</p>"},{"location":"automlst-wrapper/#visualization","title":"Visualization","text":"<p>The tree visualization represents the phylogenetic relationships between various strains of the genus. This visualization aids in understanding the genetic diversity and evolutionary history of these genomes.</p> <p></p> genome_id genus_original species_original strain phylum class order family genus species Loading... (need help?) <p>Download Table</p>"},{"location":"automlst-wrapper/#interactive-visualization-with-itol","title":"Interactive Visualization with iTOL","text":"<p>For an enhanced, interactive visualization experience, users are encouraged to download the tree file and the corresponding annotation table. These files can be uploaded to iTOL (Interactive Tree Of Life), a web-based tool for the display, manipulation, and annotation of phylogenetic trees. Please check the iTOL help page for the upload guide and annotation format.</p> <p>Download iTOL Tree Download iTOL Label Download iTOL Color</p> <p>Download antiSMASH barchart Download BiG-SCAPE GCF presence Download BiG-SCAPE barchart</p>"},{"location":"automlst-wrapper/#references","title":"References","text":"<p> <ul> <li>Letunic I and Bork P (2021) Nucleic Acids Res doi: 10.1093/nar/gkab301 Interactive Tree Of Life (iTOL) v5: an online tool for phylogenetic tree display and annotation</li> <li> <p>G Yu, DK Smith, H Zhu, Y Guan, TTY Lam<sup>*</sup>. ggtree: an     R package for visualization and annotation of phylogenetic trees     with their covariates and other associated data. Methods in     Ecology and Evolution. 2017, 8(1):28-36. doi:     10.1111/2041-210X.12628</p> </li> <li> <p>Mohammad Alanjary, Katharina Steinke, Nadine Ziemert, AutoMLST: an automated web server for generating multi-locus species trees highlighting natural product potential,Nucleic Acids Research, Volume 47, Issue W1, 02 July 2019, Pages W276\u2013W282</p> </li> </ul> <p></p>"},{"location":"bigscape/","title":"BiG-SCAPE","text":"<p>Cytoscape Network.dependency_version()}}.graphml){:target=\"_blank\" .md-button}</p> <p>Download the graphml file using the button above and import it into Cytoscape for interactive visualisation of the network.</p>"},{"location":"bigscape/#big-scape","title":"BiG-SCAPE\u00b6","text":"<p>Summary of GCFs found in each genome from project <code>[{{ project().name }}]</code> using BiG-SCAPE</p> <p>[BiG-SCAPE result]({{ project().file_server() }}/bigscape/result_as{{project().dependency_version()}}){:target=\"_blank\" .md-button}</p>"},{"location":"bigscape/#bgc-distribution","title":"BGC Distribution\u00b6","text":"<p>BiG-SCAPE constructs sequence similarity networks of Biosynthetic Gene Clusters (BGCs) and groups them into Gene Cluster Families (GCFs). BiG-SCAPE does this by rapidly calculating a distance matrix between gene clusters based on a comparison of their protein domain content, order, copy number and sequence identity.</p>"},{"location":"bigscape/#sequence-similarity-network","title":"Sequence Similarity Network\u00b6","text":""},{"location":"bigscape/#result-summary","title":"Result Summary\u00b6","text":""},{"location":"bigscape/#summary-tables","title":"Summary Tables\u00b6","text":""},{"location":"bigscape/#genome-overview","title":"Genome overview\u00b6","text":"<p>Number of BGCs of various types (known, unknown, unique) present in each genome. Additionally, number of BGCs of each of the BiG-SCAPE defined biosynthetic classes are also listed.</p>"},{"location":"bigscape/#bgc-overview","title":"BGC overview\u00b6","text":"<p>BGCs table with assignment of the GCFs based on the BiG-SCAPE.</p>"},{"location":"bigscape/#gcf-overview","title":"GCF overview\u00b6","text":"<p>GCFs table with metadata and statistics.</p>"},{"location":"bigscape/#gcf-presence-matrix","title":"GCF-presence matrix\u00b6","text":"<p>GCF presence absence matrix across all the genomes. Note that the columns are represented by the GCF IDs that can be found in GCF overview table above.</p>"},{"location":"bigscape/#mibig-overview","title":"MIBIG overview\u00b6","text":"<p>Information on the known clusters from MIBIG database detected in the genomes using BiG-SCAPE.</p>"},{"location":"bigscape/#references","title":"References\u00b6","text":"{% for i in project().rule_used['bigscape']['references'] %} - {{ i }}  {% endfor %}"},{"location":"bigscape/","title":"BiG-SCAPE","text":"<p>Summary of GCFs found in each genome from project <code>[mq_saccharopolyspora]</code> using BiG-SCAPE</p> <p>BiG-SCAPE result</p>"},{"location":"bigscape/#bgc-distribution","title":"BGC Distribution","text":"<p>BiG-SCAPE constructs sequence similarity networks of Biosynthetic Gene Clusters (BGCs) and groups them into Gene Cluster Families (GCFs). BiG-SCAPE does this by rapidly calculating a distance matrix between gene clusters based on a comparison of their protein domain content, order, copy number and sequence identity.</p>"},{"location":"bigscape/#sequence-similarity-network","title":"Sequence Similarity Network","text":"<p>Cytoscape Network</p> <p>Download the graphml file using the button above and import it into Cytoscape for interactive visualisation of the network.</p>"},{"location":"bigscape/#result-summary","title":"Result Summary","text":"<p>BiG-SCAPE detected 336 GCFs of the 739 BGCs</p> <ul> <li> <p>Number of known GCFs: 5</p> </li> <li> <p>Number of unknown GCFs: 331</p> </li> <li> <p>Number of unique GCFs: 210</p> </li> </ul>"},{"location":"bigscape/#summary-tables","title":"Summary Tables","text":""},{"location":"bigscape/#genome-overview","title":"Genome overview","text":"<p>Number of BGCs of various types (known, unknown, unique) present in each genome. Additionally, number of BGCs of each of the BiG-SCAPE defined biosynthetic classes are also listed.</p> Genome ID GTDB species BGCs Unique BGCs Others NRPS RiPPs Terpene PKSI PKSother PKS-NRP_Hybrids Saccharides GCF_003635025.1 Saccharopolyspora antimicrobica 26 0 9 2 4 7 1 1 2 0 GCF_900114905.1 Saccharopolyspora antimicrobica 26 0 9 2 4 7 1 1 2 0 GCF_007829955.1 Saccharopolyspora dendranthemae 22 9 8 1 4 6 1 0 2 0 GCF_018070075.1 Saccharopolyspora endophytica 26 13 9 1 7 7 0 0 2 0 GCF_016859185.1 Saccharopolyspora_D erythraea 38 0 13 1 7 8 4 4 1 0 GCF_018141105.1 Saccharopolyspora_D erythraea_A 37 13 14 2 7 9 2 3 0 0 GCF_022392385.1 Saccharopolyspora_D erythraea 37 1 13 1 6 8 4 4 1 0 GCF_000062885.1 Saccharopolyspora_D erythraea 37 0 12 1 7 8 4 4 1 0 GCF_002564065.1 Saccharopolyspora_D erythraea 38 0 13 1 7 8 4 4 1 0 GCF_900116135.1 Saccharopolyspora flava 19 6 5 1 3 6 0 1 3 0 GCF_014203325.1 Saccharopolyspora_C gloriosae 24 9 11 2 3 5 2 1 0 0 GCF_022828475.1 Saccharopolyspora_C sp. 25 12 9 1 4 4 3 1 2 1 GCF_024734405.1 Saccharopolyspora_C sp. 24 12 8 2 2 7 2 1 1 1 GCF_008630535.1 Saccharopolyspora hirsuta 22 11 6 2 4 5 2 3 0 0 GCF_013410345.1 Saccharopolyspora hordei 13 6 3 1 4 4 0 0 1 0 GCF_900112555.1 Saccharopolyspora kobensis 24 0 7 2 5 6 0 2 1 1 GCF_900108315.1 Saccharopolyspora kobensis 24 0 7 2 5 6 0 2 1 1 GCF_014203395.1 Saccharopolyspora phatthalungensis 36 30 10 3 5 8 5 3 2 0 GCF_014697215.1 Saccharopolyspora pogona 37 22 15 5 7 5 0 3 2 0 GCF_003931915.1 Saccharopolyspora rhizosphaerae 14 6 6 0 3 5 0 0 0 0 GCF_025643595.1 Saccharopolyspora sp. 19 16 7 3 3 4 1 1 0 0 GCF_012277335.1 Saccharopolyspora pogona 32 19 14 3 6 4 0 3 2 0 GCF_016526145.1 Saccharopolyspora_C sp016526145 26 21 7 2 9 4 1 1 0 2 GCF_014490055.1 Saccharopolyspora spinosa 38 1 15 7 3 5 1 5 2 0 GCF_002846475.1 Saccharopolyspora spinosa 38 0 15 7 3 5 2 4 2 0 GCF_000194155.1 Saccharopolyspora spinosa 37 3 15 5 3 5 2 4 3 0"},{"location":"bigscape/#bgc-overview","title":"BGC overview","text":"<p>BGCs table with assignment of the GCFs based on the BiG-SCAPE.</p> antiSMASH Product BiG-SCAPE Class Genome ID gcf_0.30 fam_id_0.30 fam_type_0.30 fam_known_compounds_0.30 BGC ID Loading... (need help?)"},{"location":"bigscape/#gcf-overview","title":"GCF overview","text":"<p>GCFs table with metadata and statistics.</p> fam_type fam_name clusters_in_fam mibig_ids fam_id_0.30 1 unknown_family u_Others_1 26 nan 2 unknown_family u_Terpene_2 26 nan 3 unknown_family u_Others_3 18 nan 4 unknown_family u_Terpene_4 18 nan 5 unknown_family u_Terpene_5 7 nan 6 known_family erythromycin A;erythromycin B;erythromycin C;erythromycin D 6 BGC0000055 7 unknown_family u_Others_7 6 nan 8 known_family antimycin;splenocin C;antimycin 6 BGC0001455;BGC0001216;BGC0000958 9 unknown_family u_RiPPs_9 6 nan 10 known_family Ery-9;Ery-6;Ery-8;Ery-7;Ery-5;Ery-4;Ery-3 6 BGC0000513 11 known_family 2-methylisoborneol 6 BGC0000659 12 unknown_family u_PKSI_12 5 nan 13 unknown_family u_Others_13 5 nan 14 unknown_family u_Others_14 5 nan 15 unknown_family u_Others_15 5 nan 16 unknown_family u_Others_16 5 nan 17 unknown_family u_Others_17 5 nan 18 unknown_family u_Others_18 5 nan 19 unknown_family u_Others_19 5 nan 20 unknown_family u_Others_20 5 nan 21 unknown_family u_Others_21 5 nan 22 unknown_family u_Others_22 5 nan 23 unknown_family u_Others_23 5 nan 24 unknown_family u_PKSother_24 5 nan 25 unknown_family u_NRPS_25 5 nan 26 unknown_family u_RiPPs_26 5 nan 27 unknown_family u_RiPPs_27 5 nan 28 unknown_family u_RiPPs_28 5 nan 29 unknown_family u_Terpene_29 5 nan 30 unknown_family u_Terpene_30 5 nan 31 unknown_family u_Terpene_31 5 nan 32 unknown_family u_Terpene_32 5 nan 33 unknown_family u_Terpene_33 5 nan 34 unknown_family u_Terpene_34 5 nan 35 unknown_family u_PKSI_35 4 nan 36 unknown_family u_PKSI_36 4 nan 37 unknown_family u_Others_37 4 nan 38 unknown_family u_Others_38 4 nan 39 unknown_family u_Others_39 4 nan 40 unknown_family u_Others_40 4 nan 41 unknown_family u_Others_41 4 nan 42 unknown_family u_Others_42 4 nan 43 unknown_family u_Others_43 4 nan 44 unknown_family u_Others_44 4 nan 45 unknown_family u_Others_45 4 nan 46 unknown_family u_Others_46 4 nan 47 unknown_family u_PKS-NRP_Hybrids_47 4 nan 48 unknown_family u_PKS-NRP_Hybrids_48 4 nan 49 unknown_family u_PKSother_49 4 nan 50 unknown_family u_PKSother_50 4 nan 51 unknown_family u_PKSother_51 4 nan 52 unknown_family u_PKSother_52 4 nan 53 unknown_family u_NRPS_53 4 nan 54 unknown_family u_NRPS_54 4 nan 55 unknown_family u_NRPS_55 4 nan 56 unknown_family u_NRPS_56 4 nan 57 unknown_family u_RiPPs_57 4 nan 58 unknown_family u_RiPPs_58 4 nan 59 unknown_family u_RiPPs_59 4 nan 60 unknown_family u_RiPPs_60 4 nan 61 unknown_family u_RiPPs_61 4 nan 62 unknown_family u_RiPPs_62 4 nan 63 unknown_family u_RiPPs_63 4 nan 64 unknown_family u_RiPPs_64 4 nan 65 unknown_family u_RiPPs_65 4 nan 66 unknown_family u_RiPPs_66 4 nan 67 unknown_family u_Terpene_67 4 nan 68 unknown_family u_Terpene_68 4 nan 69 unknown_family u_Terpene_69 4 nan 70 unknown_family u_Terpene_70 4 nan 71 unknown_family u_Terpene_71 4 nan 72 unknown_family u_Terpene_72 4 nan 73 unknown_family u_PKSI_73 3 nan 74 unknown_family u_Others_74 3 nan 75 unknown_family u_Others_75 3 nan 76 unknown_family u_Others_76 3 nan 77 unknown_family u_Others_77 3 nan 78 unknown_family u_Others_78 3 nan 79 unknown_family u_Others_79 3 nan 80 unknown_family u_Others_80 3 nan 81 unknown_family u_Others_81 3 nan 82 unknown_family u_Others_82 3 nan 83 unknown_family u_Others_83 3 nan 84 unknown_family u_Others_84 3 nan 85 unknown_family u_PKS-NRP_Hybrids_85 3 nan 86 unknown_family u_PKS-NRP_Hybrids_86 3 nan 87 unknown_family u_PKS-NRP_Hybrids_87 3 nan 88 unknown_family u_PKSother_88 3 nan 89 unknown_family u_PKSother_89 3 nan 90 unknown_family u_PKSother_90 3 nan 91 unknown_family u_NRPS_91 3 nan 92 unknown_family u_NRPS_92 3 nan 93 unknown_family u_NRPS_93 3 nan 94 unknown_family u_NRPS_94 3 nan 95 unknown_family u_NRPS_95 3 nan 96 unknown_family u_RiPPs_96 3 nan 97 unknown_family u_RiPPs_97 3 nan 98 unknown_family u_RiPPs_98 3 nan 99 unknown_family u_Terpene_99 3 nan 100 unknown_family u_Terpene_100 3 nan 101 unknown_family u_Terpene_101 3 nan 102 unknown_family u_Terpene_102 3 nan 103 unknown_family u_PKSI_103 2 nan 104 unknown_family u_PKSI_104 2 nan 105 known_family A83543A 2 BGC0000148 106 unknown_family u_PKSI_106 2 nan 107 unknown_family u_Others_107 2 nan 108 unknown_family u_Others_108 2 nan 109 unknown_family u_Others_109 2 nan 110 unknown_family u_Others_110 2 nan 111 unknown_family u_Others_111 2 nan 112 unknown_family u_Others_112 2 nan 113 unknown_family u_Others_113 2 nan 114 unknown_family u_PKS-NRP_Hybrids_114 2 nan 115 unknown_family u_PKSother_115 2 nan 116 unknown_family u_PKSother_116 2 nan 117 unknown_family u_PKSother_117 2 nan 118 unknown_family u_Saccharides_118 2 nan 119 unknown_family u_NRPS_119 2 nan 120 unknown_family u_NRPS_120 2 nan 121 unknown_family u_RiPPs_121 2 nan 122 unknown_family u_RiPPs_122 2 nan 123 unknown_family u_RiPPs_123 2 nan 124 unknown_family u_Terpene_124 2 nan 125 unknown_family u_Terpene_125 2 nan 126 unknown_family u_Terpene_126 2 nan 127 unknown_family u_PKSI_127 1 nan 128 unknown_family u_PKSI_128 1 nan 129 unknown_family u_PKSI_129 1 nan 130 unknown_family u_PKSI_130 1 nan 131 unknown_family u_PKSI_131 1 nan 132 unknown_family u_PKSI_132 1 nan 133 unknown_family u_PKSI_133 1 nan 134 unknown_family u_PKSI_134 1 nan 135 unknown_family u_PKSI_135 1 nan 136 unknown_family u_PKSI_136 1 nan 137 unknown_family u_PKSI_137 1 nan 138 unknown_family u_PKSI_138 1 nan 139 unknown_family u_PKSI_139 1 nan 140 unknown_family u_PKSI_140 1 nan 141 unknown_family u_Others_141 1 nan 142 unknown_family u_Others_142 1 nan 143 unknown_family u_Others_143 1 nan 144 unknown_family u_Others_144 1 nan 145 unknown_family u_Others_145 1 nan 146 unknown_family u_Others_146 1 nan 147 unknown_family u_Others_147 1 nan 148 unknown_family u_Others_148 1 nan 149 unknown_family u_Others_149 1 nan 150 unknown_family u_Others_150 1 nan 151 unknown_family u_Others_151 1 nan 152 unknown_family u_Others_152 1 nan 153 unknown_family u_Others_153 1 nan 154 unknown_family u_Others_154 1 nan 155 unknown_family u_Others_155 1 nan 156 unknown_family u_Others_156 1 nan 157 unknown_family u_Others_157 1 nan 158 unknown_family u_Others_158 1 nan 159 unknown_family u_Others_159 1 nan 160 unknown_family u_Others_160 1 nan 161 unknown_family u_Others_161 1 nan 162 unknown_family u_Others_162 1 nan 163 unknown_family u_Others_163 1 nan 164 unknown_family u_Others_164 1 nan 165 unknown_family u_Others_165 1 nan 166 unknown_family u_Others_166 1 nan 167 unknown_family u_Others_167 1 nan 168 unknown_family u_Others_168 1 nan 169 unknown_family u_Others_169 1 nan 170 unknown_family u_Others_170 1 nan 171 unknown_family u_Others_171 1 nan 172 unknown_family u_Others_172 1 nan 173 unknown_family u_Others_173 1 nan 174 unknown_family u_Others_174 1 nan 175 unknown_family u_Others_175 1 nan 176 unknown_family u_Others_176 1 nan 177 unknown_family u_Others_177 1 nan 178 unknown_family u_Others_178 1 nan 179 unknown_family u_Others_179 1 nan 180 unknown_family u_Others_180 1 nan 181 unknown_family u_Others_181 1 nan 182 unknown_family u_Others_182 1 nan 183 unknown_family u_Others_183 1 nan 184 unknown_family u_Others_184 1 nan 185 unknown_family u_Others_185 1 nan 186 unknown_family u_Others_186 1 nan 187 unknown_family u_Others_187 1 nan 188 unknown_family u_Others_188 1 nan 189 unknown_family u_Others_189 1 nan 190 unknown_family u_Others_190 1 nan 191 unknown_family u_Others_191 1 nan 192 unknown_family u_Others_192 1 nan 193 unknown_family u_Others_193 1 nan 194 unknown_family u_Others_194 1 nan 195 unknown_family u_Others_195 1 nan 196 unknown_family u_Others_196 1 nan 197 unknown_family u_Others_197 1 nan 198 unknown_family u_Others_198 1 nan 199 unknown_family u_Others_199 1 nan 200 unknown_family u_Others_200 1 nan 201 unknown_family u_Others_201 1 nan 202 unknown_family u_Others_202 1 nan 203 unknown_family u_Others_203 1 nan 204 unknown_family u_Others_204 1 nan 205 unknown_family u_Others_205 1 nan 206 unknown_family u_Others_206 1 nan 207 unknown_family u_Others_207 1 nan 208 unknown_family u_Others_208 1 nan 209 unknown_family u_PKS-NRP_Hybrids_209 1 nan 210 unknown_family u_PKS-NRP_Hybrids_210 1 nan 211 unknown_family u_PKS-NRP_Hybrids_211 1 nan 212 unknown_family u_PKS-NRP_Hybrids_212 1 nan 213 unknown_family u_PKS-NRP_Hybrids_213 1 nan 214 unknown_family u_PKS-NRP_Hybrids_214 1 nan 215 unknown_family u_PKS-NRP_Hybrids_215 1 nan 216 unknown_family u_PKS-NRP_Hybrids_216 1 nan 217 unknown_family u_PKS-NRP_Hybrids_217 1 nan 218 unknown_family u_PKS-NRP_Hybrids_218 1 nan 219 unknown_family u_PKS-NRP_Hybrids_219 1 nan 220 unknown_family u_PKS-NRP_Hybrids_220 1 nan 221 unknown_family u_PKSother_221 1 nan 222 unknown_family u_PKSother_222 1 nan 223 unknown_family u_PKSother_223 1 nan 224 unknown_family u_PKSother_224 1 nan 225 unknown_family u_PKSother_225 1 nan 226 unknown_family u_PKSother_226 1 nan 227 unknown_family u_PKSother_227 1 nan 228 unknown_family u_PKSother_228 1 nan 229 unknown_family u_PKSother_229 1 nan 230 unknown_family u_PKSother_230 1 nan 231 unknown_family u_PKSother_231 1 nan 232 unknown_family u_PKSother_232 1 nan 233 unknown_family u_PKSother_233 1 nan 234 unknown_family u_PKSother_234 1 nan 235 unknown_family u_PKSother_235 1 nan 236 unknown_family u_PKSother_236 1 nan 237 unknown_family u_PKSother_237 1 nan 238 unknown_family u_PKSother_238 1 nan 239 unknown_family u_PKSother_239 1 nan 240 unknown_family u_PKSother_240 1 nan 241 unknown_family u_Saccharides_241 1 nan 242 unknown_family u_Saccharides_242 1 nan 243 unknown_family u_Saccharides_243 1 nan 244 unknown_family u_Saccharides_244 1 nan 245 unknown_family u_NRPS_245 1 nan 246 unknown_family u_NRPS_246 1 nan 247 unknown_family u_NRPS_247 1 nan 248 unknown_family u_NRPS_248 1 nan 249 unknown_family u_NRPS_249 1 nan 250 unknown_family u_NRPS_250 1 nan 251 unknown_family u_NRPS_251 1 nan 252 unknown_family u_NRPS_252 1 nan 253 unknown_family u_NRPS_253 1 nan 254 unknown_family u_NRPS_254 1 nan 255 unknown_family u_NRPS_255 1 nan 256 unknown_family u_NRPS_256 1 nan 257 unknown_family u_NRPS_257 1 nan 258 unknown_family u_NRPS_258 1 nan 259 unknown_family u_NRPS_259 1 nan 260 unknown_family u_NRPS_260 1 nan 261 unknown_family u_NRPS_261 1 nan 262 unknown_family u_NRPS_262 1 nan 263 unknown_family u_NRPS_263 1 nan 264 unknown_family u_NRPS_264 1 nan 265 unknown_family u_RiPPs_265 1 nan 266 unknown_family u_RiPPs_266 1 nan 267 unknown_family u_RiPPs_267 1 nan 268 unknown_family u_RiPPs_268 1 nan 269 unknown_family u_RiPPs_269 1 nan 270 unknown_family u_RiPPs_270 1 nan 271 unknown_family u_RiPPs_271 1 nan 272 unknown_family u_RiPPs_272 1 nan 273 unknown_family u_RiPPs_273 1 nan 274 unknown_family u_RiPPs_274 1 nan 275 unknown_family u_RiPPs_275 1 nan 276 unknown_family u_RiPPs_276 1 nan 277 unknown_family u_RiPPs_277 1 nan 278 unknown_family u_RiPPs_278 1 nan 279 unknown_family u_RiPPs_279 1 nan 280 unknown_family u_RiPPs_280 1 nan 281 unknown_family u_RiPPs_281 1 nan 282 unknown_family u_RiPPs_282 1 nan 283 unknown_family u_RiPPs_283 1 nan 284 unknown_family u_RiPPs_284 1 nan 285 unknown_family u_RiPPs_285 1 nan 286 unknown_family u_RiPPs_286 1 nan 287 unknown_family u_RiPPs_287 1 nan 288 unknown_family u_RiPPs_288 1 nan 289 unknown_family u_RiPPs_289 1 nan 290 unknown_family u_RiPPs_290 1 nan 291 unknown_family u_RiPPs_291 1 nan 292 unknown_family u_RiPPs_292 1 nan 293 unknown_family u_RiPPs_293 1 nan 294 unknown_family u_RiPPs_294 1 nan 295 unknown_family u_RiPPs_295 1 nan 296 unknown_family u_RiPPs_296 1 nan 297 unknown_family u_RiPPs_297 1 nan 298 unknown_family u_RiPPs_298 1 nan 299 unknown_family u_RiPPs_299 1 nan 300 unknown_family u_RiPPs_300 1 nan 301 unknown_family u_RiPPs_301 1 nan 302 unknown_family u_RiPPs_302 1 nan 303 unknown_family u_RiPPs_303 1 nan 304 unknown_family u_RiPPs_304 1 nan 305 unknown_family u_RiPPs_305 1 nan 306 unknown_family u_RiPPs_306 1 nan 307 unknown_family u_RiPPs_307 1 nan 308 unknown_family u_RiPPs_308 1 nan 309 unknown_family u_Terpene_309 1 nan 310 unknown_family u_Terpene_310 1 nan 311 unknown_family u_Terpene_311 1 nan 312 unknown_family u_Terpene_312 1 nan 313 unknown_family u_Terpene_313 1 nan 314 unknown_family u_Terpene_314 1 nan 315 unknown_family u_Terpene_315 1 nan 316 unknown_family u_Terpene_316 1 nan 317 unknown_family u_Terpene_317 1 nan 318 unknown_family u_Terpene_318 1 nan 319 unknown_family u_Terpene_319 1 nan 320 unknown_family u_Terpene_320 1 nan 321 unknown_family u_Terpene_321 1 nan 322 unknown_family u_Terpene_322 1 nan 323 unknown_family u_Terpene_323 1 nan 324 unknown_family u_Terpene_324 1 nan 325 unknown_family u_Terpene_325 1 nan 326 unknown_family u_Terpene_326 1 nan 327 unknown_family u_Terpene_327 1 nan 328 unknown_family u_Terpene_328 1 nan 329 unknown_family u_Terpene_329 1 nan 330 unknown_family u_Terpene_330 1 nan 331 unknown_family u_Terpene_331 1 nan 332 unknown_family u_Terpene_332 1 nan 333 unknown_family u_Terpene_333 1 nan 334 unknown_family u_Terpene_334 1 nan 335 unknown_family u_Terpene_335 1 nan 336 unknown_family u_Terpene_336 1 nan"},{"location":"bigscape/#gcf-presence-matrix","title":"GCF-presence matrix","text":"<p>GCF presence absence matrix across all the genomes. Note that the columns are represented by the GCF IDs that can be found in GCF overview table above.</p>"},{"location":"bigscape/#mibig-overview","title":"MIBIG overview","text":"<p>Information on the known clusters from MIBIG database detected in the genomes using BiG-SCAPE.</p> MIBIG ID BGC type bigscape_class biosyn_class Compounds Activity accession completeness organism_name ncbi_tax_id publications evidence gcf_0.30 gcf_0.40 gcf_0.50 Clan Number fam_id_0.30 fam_type_0.30 fam_known_compounds_0.30 Genomes 0 T1PKS PKSI Polyketide;Saccharide erythromycin A;erythromycin B;erythromycin C;erythromycin D antibacterial;inhibitor AM420293.1 complete Saccharopolyspora erythraea NRRL 2338 405948 pubmed:11336289;pubmed:24704088;pubmed:23902230;pubmed:21175699;pubmed:18836015;pubmed:18223111;pubmed:17369815;pubmed:16491356;pubmed:15575696;pubmed:15303858;pubmed:12904561;pubmed:12435693;pubmed:10559177;pubmed:9613575;pubmed:9563840;pubmed:9493390;pubmed:9393448;pubmed:9353926;pubmed:7737500;pubmed:7749919;pubmed:8300527;pubmed:8448148;pubmed:8449313;pubmed:8416893;pubmed:1618327;pubmed:1840640;pubmed:2234082;pubmed:2185216;pubmed:2681144;pubmed:2575703;pubmed:2469627 Knock-out studies;Enzymatic assays;Heterologous expression;Gene expression correlated with compound production 3070 3070 3070 nan 6 known_family erythromycin A;erythromycin B;erythromycin C;erythromycin D 0 1 T1PKS PKSI Polyketide A83543A nan AY007564.1 Unknown Saccharopolyspora spinosa 60894 pubmed:11358695 nan 3136 3136 3136 nan 105 known_family A83543A 0 2 lanthipeptide-class-iii RiPPs RiPP Ery-9;Ery-6;Ery-8;Ery-7;Ery-5;Ery-4;Ery-3 nan AM420293.1 complete Saccharopolyspora erythraea NRRL 2338 405948 pubmed:22556031 Heterologous expression 475 475 2742 nan 10 known_family Ery-9;Ery-6;Ery-8;Ery-7;Ery-5;Ery-4;Ery-3 0 3 terpene Terpene Terpene 2-methylisoborneol nan AM420293.1 Unknown Saccharopolyspora erythraea NRRL 2338 405948 pubmed:17369815 nan 2738 2738 2738 2559.000000 11 known_family 2-methylisoborneol 0"},{"location":"bigscape/#references","title":"References","text":"<p> <ul> <li>Navarro-Mu\u00f1oz, J.C., Selem-Mojica, N., Mullowney, M.W. et al. A computational framework to explore large-scale biosynthetic diversity. Nat Chem Biol 16, 60\u201368 (2020) </li> </ul> <p></p>"},{"location":"bigslice/","title":"BiG-SLICE","text":""},{"location":"bigslice/#big-slice","title":"BiG-SLICE\u00b6","text":"<p>Summary of BiG-SLICE results from project: <code>[{{ project().name }}]</code></p>"},{"location":"bigslice/#description","title":"Description\u00b6","text":"<p>A highly scalable, user-interactive tool for the large scale analysis of Biosynthetic Gene Clusters data.</p>"},{"location":"bigslice/#usage","title":"Usage\u00b6","text":"<p>You can start the BiG-SLICE flask app to view the clustering result.</p> <p>Steps:</p>"},{"location":"bigslice/#references","title":"References\u00b6","text":"<p>{% for i in project().rule_used['bigslice']['references'] %}</p> <ul> <li>{{ i }} {% endfor %}</li> </ul>"},{"location":"bigslice/","title":"BiG-SLICE","text":"<p>Summary of BiG-SLICE results from project: <code>[mq_saccharopolyspora]</code> </p>"},{"location":"bigslice/#description","title":"Description","text":"<p>A highly scalable, user-interactive tool for the large scale analysis of Biosynthetic Gene Clusters data.</p>"},{"location":"bigslice/#usage","title":"Usage","text":"<p>You can start the BiG-SLICE flask app to view the clustering result.</p> <p>Steps:</p> <ul> <li>Install the conda environment:</li> </ul> <pre><code>    conda install -f /data/matinnu/mq_saccharopolyspora/data/processed/mq_saccharopolyspora/docs/assets/envs/bigslice.yaml\n</code></pre> <ul> <li>Run the app</li> </ul> <pre><code>    port='5001'\n    conda run -n bigslice bash /data/matinnu/mq_saccharopolyspora/data/processed/mq_saccharopolyspora/cluster_as_7.1.0/start_server.sh $port\n</code></pre>"},{"location":"bigslice/#references","title":"References","text":"<p> <ul> <li>Satria A Kautsar, Justin J J van der Hooft, Dick de Ridder, Marnix H Medema, BiG-SLiCE: A highly scalable tool maps the diversity of 1.2 million biosynthetic gene clusters, GigaScience, Volume 10, Issue 1, January 2021, giaa154</li> </ul> <p></p>"},{"location":"cblaster-bgc/","title":"cblaster-bgc","text":""},{"location":"cblaster-bgc/#cblaster-bgc","title":"cblaster-bgc\u00b6","text":"<p>Summary of cblaster-bgc results from project: <code>[{{ project().name }}]</code></p>"},{"location":"cblaster-bgc/#description","title":"Description\u00b6","text":"<p>Build a diamond database of all BGCs in the project for clustered hits from a BLAST search using cblaster.</p>"},{"location":"cblaster-bgc/#how-to-run-query-from-local-database","title":"How to run query from local database\u00b6","text":"<ul> <li>Download all files from the CBlaster result:</li> </ul> <p>[CBlaster database]({{ project().file_server() }}/cblaster/bgc){:target=\"_blank\" .md-button}</p> <ul> <li>Install CBlaster conda environment using this yaml configuration (create a file called <code>env.yaml</code> and copy paste the following items to the file). See the conda guide here:</li> </ul> <pre>name: cblaster\nchannels:\n  - conda-forge\n  - default\n  - bioconda\ndependencies:\n  - diamond==2.0.15\n  - pip\n  - pip:\n    - cblaster==1.3.12\n</pre> <ul> <li>After having the environment installed, <code>cd</code> to the directory containing all the files, activate the environment, and run queries by:</li> </ul> <pre># activate environment\nconda activate cblaster\ncblaster search -m local -db cblaster_genome_db.dmnd -qf &lt;query.faa&gt;\n</pre> <ul> <li>See CBlaster guide for running local queries here</li> </ul>"},{"location":"cblaster-bgc/#references","title":"References\u00b6","text":"<p>{% for i in project().rule_used['cblaster-bgc']['references'] %}</p> <ul> <li>{{ i }} {% endfor %}</li> </ul>"},{"location":"cblaster-bgc/","title":"cblaster-bgc","text":"<p>Summary of cblaster-bgc results from project: <code>[mq_saccharopolyspora]</code> </p>"},{"location":"cblaster-bgc/#description","title":"Description","text":"<p>Build a diamond database of all BGCs in the project for clustered hits from a BLAST search using cblaster.</p>"},{"location":"cblaster-bgc/#how-to-run-query-from-local-database","title":"How to run query from local database","text":"<ul> <li>Download all files from the CBlaster result:</li> </ul> <p>CBlaster database</p> <ul> <li>Install CBlaster conda environment using this yaml configuration (create a file called <code>env.yaml</code> and copy paste the following items to the file). See the conda guide here:</li> </ul> <pre><code>name: cblaster\nchannels:\n  - conda-forge\n  - default\n  - bioconda\ndependencies:\n  - diamond==2.0.15\n  - pip\n  - pip:\n    - cblaster==1.3.12\n</code></pre> <ul> <li>After having the environment installed, <code>cd</code> to the directory containing all the files, activate the environment, and run queries by:</li> </ul> <pre><code># activate environment\nconda activate cblaster\ncblaster search -m local -db cblaster_genome_db.dmnd -qf &lt;query.faa&gt;\n</code></pre> <ul> <li>See CBlaster guide for running local queries here</li> </ul>"},{"location":"cblaster-bgc/#references","title":"References","text":"<p> <ul> <li> <p>Gilchrist, C., Booth, T. J., van Wersch, B., van Grieken, L., Medema, M. H., &amp; Chooi, Y. (2021). cblaster: a remote search tool for rapid identification and visualisation of homologous gene clusters (Version 1.3.9) [Computer software]. https://doi.org/10.1101/2020.11.08.370601</p> </li> <li> <p>Buchfink, B., Xie, C. &amp; Huson, D. H. Fast and sensitive protein alignment using DIAMOND. Nat. Methods 12, 59\u201360 (2015).</p> </li> </ul> <p></p>"},{"location":"cblaster-genome/","title":"cblaster-genome","text":""},{"location":"cblaster-genome/#cblaster-genome","title":"cblaster-genome\u00b6","text":"<p>Summary of cblaster-genome results from project: <code>[{{ project().name }}]</code></p>"},{"location":"cblaster-genome/#description","title":"Description\u00b6","text":"<p>Build a diamond database of all genomes in the project for clustered hits from a BLAST search using <code>cblaster</code>.</p>"},{"location":"cblaster-genome/#how-to-run-query-from-local-database","title":"How to run query from local database\u00b6","text":"<ul> <li>Download all files from the CBlaster result:</li> </ul> <p>[CBlaster database]({{ project().file_server() }}/cblaster/genomes){:target=\"_blank\" .md-button}</p> <ul> <li>Install CBlaster conda environment using this yaml configuration (create a file called <code>env.yaml</code> and copy paste the following items to the file). See the conda guide here:</li> </ul> <pre>name: cblaster\nchannels:\n  - conda-forge\n  - default\n  - bioconda\ndependencies:\n  - diamond==2.0.15\n  - pip\n  - pip:\n    - cblaster==1.3.12\n</pre> <ul> <li>After having the environment installed, <code>cd</code> to the directory containing all the files, activate the environment, and run queries by:</li> </ul> <pre># activate environment\nconda activate cblaster\ncblaster search -m local -db cblaster_genome_db.dmnd -qf &lt;query.faa&gt;\n</pre> <ul> <li>See CBlaster guide for running local queries here</li> </ul>"},{"location":"cblaster-genome/#references","title":"References\u00b6","text":"<p>{% for i in project().rule_used['cblaster-genome']['references'] %}</p> <ul> <li>{{ i }} {% endfor %}</li> </ul>"},{"location":"cblaster-genome/","title":"cblaster-genome","text":"<p>Summary of cblaster-genome results from project: <code>[mq_saccharopolyspora]</code> </p>"},{"location":"cblaster-genome/#description","title":"Description","text":"<p>Build a diamond database of all genomes in the project for clustered hits from a BLAST search using <code>cblaster</code>.</p>"},{"location":"cblaster-genome/#how-to-run-query-from-local-database","title":"How to run query from local database","text":"<ul> <li>Download all files from the CBlaster result:</li> </ul> <p>CBlaster database</p> <ul> <li>Install CBlaster conda environment using this yaml configuration (create a file called <code>env.yaml</code> and copy paste the following items to the file). See the conda guide here:</li> </ul> <pre><code>name: cblaster\nchannels:\n  - conda-forge\n  - default\n  - bioconda\ndependencies:\n  - diamond==2.0.15\n  - pip\n  - pip:\n    - cblaster==1.3.12\n</code></pre> <ul> <li>After having the environment installed, <code>cd</code> to the directory containing all the files, activate the environment, and run queries by:</li> </ul> <pre><code># activate environment\nconda activate cblaster\ncblaster search -m local -db cblaster_genome_db.dmnd -qf &lt;query.faa&gt;\n</code></pre> <ul> <li>See CBlaster guide for running local queries here</li> </ul>"},{"location":"cblaster-genome/#references","title":"References","text":"<p> <ul> <li> <p>Gilchrist, C., Booth, T. J., van Wersch, B., van Grieken, L., Medema, M. H., &amp; Chooi, Y. (2021). cblaster: a remote search tool for rapid identification and visualisation of homologous gene clusters (Version 1.3.9) [Computer software]. https://doi.org/10.1101/2020.11.08.370601</p> </li> <li> <p>Buchfink, B., Xie, C. &amp; Huson, D. H. Fast and sensitive protein alignment using DIAMOND. Nat. Methods 12, 59\u201360 (2015).</p> </li> </ul> <p></p>"},{"location":"checkm/","title":"CheckM","text":""},{"location":"checkm/#checkm","title":"CheckM\u00b6","text":"<p>Summary of CheckM results from project: <code>[{{ project().name }}]</code></p>"},{"location":"checkm/#description","title":"Description\u00b6","text":"<p>Assess the quality of microbial genomes recovered from isolates, single cells, and metagenomes</p>"},{"location":"checkm/#result","title":"Result\u00b6","text":""},{"location":"checkm/#references","title":"References\u00b6","text":"<p>{% for i in project().rule_used['checkm']['references'] %}</p> <ul> <li>{{ i }} {% endfor %}</li> </ul>"},{"location":"checkm/","title":"CheckM","text":"<p>Summary of CheckM results from project: <code>[mq_saccharopolyspora]</code> </p>"},{"location":"checkm/#description","title":"Description","text":"<p>Assess the quality of microbial genomes recovered from isolates, single cells, and metagenomes</p>"},{"location":"checkm/#result","title":"Result","text":"<pre><code>high_quality=25, medium_quality=1, low_quality=0, contaminated=0, unknown=0\n</code></pre>"},{"location":"checkm/#references","title":"References","text":"<p> <ul> <li>Parks DH, Imelfort M, Skennerton CT, Hugenholtz P, Tyson GW. 2014. Assessing the quality of microbial genomes recovered from isolates, single cells, and metagenomes. Genome Research, 25: 1043-1055.</li> </ul> <p></p>"},{"location":"custom_tutorial/","title":"Finish running BGCFlow","text":"<p>This tutorial aims to show the flexibility of modifying, or generating markdown reports from BGCFlow template notebooks.</p> <p>We will go through a simple analysis of filtering results from different genome mining tools and finding our BGC of interest.</p> <pre># Finish running BGCFlow\nbgcflow run\n\n# Build the report\nbgcflow build report\n</pre> <p>Once the run finishes, check the result in the processed directory (<code>data/processed/mq_saccharopolyspora</code>), it should generate a folder structure similar to this:</p> <pre><code>.\n\u251c\u2500\u2500 antismash\n\u251c\u2500\u2500 bigscape\n\u251c\u2500\u2500 bigslice\n\u251c\u2500\u2500 data_warehouse\n\u251c\u2500\u2500 docs\n\u2502   \u251c\u2500\u2500 antismash.ipynb\n\u2502   \u251c\u2500\u2500 antismash.md\n\u2502   \u251c\u2500\u2500 arts.ipynb\n\u2502   \u251c\u2500\u2500 arts.md\n\u2502   \u251c\u2500\u2500 assets\n\u2502   \u251c\u2500\u2500 bigscape.ipynb\n\u2502   \u251c\u2500\u2500 bigscape.md\n\u2502   \u251c\u2500\u2500 index.md\n\u2502   \u251c\u2500\u2500 query-bigslice.ipynb\n\u2502   \u2514\u2500\u2500 query-bigslice.md\n\u251c\u2500\u2500 log_changes\n\u251c\u2500\u2500 main.py\n\u251c\u2500\u2500 metadata\n\u251c\u2500\u2500 mkdocs.yml\n\u251c\u2500\u2500 overrides\n\u251c\u2500\u2500 README.md\n\u2514\u2500\u2500 tables\n</code></pre> <p>BGCFlow contains a starter Jupyter notebook template, generated in the <code>docs</code> folder, which are then converted to a <code>markdown</code> file, which can be used by <code>mkdocs</code> to generate a static HTML site.</p> <p>For more details about customizing the HTML report, see https://squidfunk.github.io/mkdocs-material/</p> <p>To add your own analysis, you can start up Jupyter session using the environments above, and create a new notebook inside the <code>docs</code> folder. You can also download this notebook tutorial here:</p> <p>Download Notebook</p> <p>Let's give our notebook the name <code>custom_tutorial.ipynb</code></p> <p>First, let's import the necessary Python libraries and define the directory containing our report data.</p> <p>Note from the code that the report directory is located one directory above of this notebook (which is located in the <code>docs</code> folder)</p> <p>The <code>metadata</code> folder records some of the important software versions and also other information of the BGCFlow runs. First, we will fetch the <code>antiSMASH</code> version used in the run from the metadata.</p> <p>Some other tables are located in their specific directories, such BiG-SCAPE</p> <p>Other tables are created by the Jupyter notebook templates, and usually can be interactively downloaded from the HTML report. By convention, this are stored in the <code>assets</code> directory within the <code>docs</code> folder.</p> <p>While pandas can show nice summary of a table, it does not do so interactively, and does not render well in the HTML report. We can use itables to display our tables as interactive datatables that we can sort, paginate, scroll or filter. To enable this feature in the final report, we are converting the tables to HTML datatables and displaying it with iPython.</p> <p>Note that these tables are downsampled by default to prevent the Markdown report become heavy. See https://mwouts.github.io/itables/downsampling.html for more details.</p> <p>We do not recommend to use the HTML reports to show big tables as it's purpose is to give a quick summary of the analysis.</p> <p>BiG-SCAPE filtering</p> <p>Let's start by looking at the BiG-SCAPE category of unknown PKS. We will create a filtering following this logic:</p> <ul> <li><p>Define Classes to Filter By: We will select all possible PKS categories in BiG-SCAPE and put it in a list named bigscape_class, containing PKSI, PKSother, and PKS-NRP_Hybrids. To see all available bigscape_class, do: <code>df_bigscape[\"bigscape_class\"].unique()</code></p> </li> <li><p>Filter for unknown families: The column <code>fam_type_0.30</code> defines whether the BGCs belongs to a known or unknown GCFs using the cutoff value of 0.3. We will set the string variable family_type to \"unknown_family\", which then used to filter rows based on a column in the DataFrame related to family types.</p> </li> <li><p>Create Masks for Filtering:</p> <ul> <li><p>mask1: This is a boolean mask created by checking if the values in the column fam_type_0.30 of df_bigscape are equal to family_type (\"unknown_family\"). This mask is true for rows where the family type is unknown.</p> </li> <li><p>mask2: This is another boolean mask created by checking if the values in the column bigscape_class are within the list bigscape_class defined at the start. This mask is true for rows that match any of the specified classes (PKSI, PKSother, PKS-NRP_Hybrids).</p> </li> </ul> </li> <li><p>Filter DataFrame: The DataFrame df_bigscape is filtered using the logical AND (&amp;) of mask1 and mask2. This means only rows where both conditions are true (i.e., the family type is \"unknown_family\" and the bigscape class is one of the specified classes) are selected.</p> </li> </ul> <p>AntiSMASH KnownClusterBlast filtering</p> <p>We will now look at the KnownClusterBlast similarity score and decide if we need to further filter our search. We will subset the antiSMASH BGC regions table to only contains BGCs identified in the previous step and observe the KnownClusterBlast similarity values. We will narrow down our search by setting up a threshold for the similarity score.</p> <p>BiG-FAM query filtering</p> <p>We will also remove all BGCs that has a match to other BGCs in the BiG-FAM database.</p> <p>ARTS hits filtering</p> <p>We will now select only BGCs with close proximity to one of the ARTS2 model. Note that ARTS2 actually have several criteria to prioritise BGCs with possible antibiotic activity, here we just search for all BGCs that has hits to ARTS2 profile.</p> <p>This tutorial help us narrow down our search to potentially novel PKS. Nevertheless, an in-depth investigation to the BGC structure and see if it has all the required genes to perform natural product biosynthesis.</p> <p>We also recommend users to try out <code>Metabase</code> for a more interactive experience of exploring the datasets. See the how to guide in our WiKi</p> <p>And then we will first list all the files that we need:</p> <p>We will start by reading the input files into memory:</p> <p>And then continue by filtering the networks based on our cutoff definition.</p> <p>In this first part, we will split again the BiG-SCAPE - antiSMASH KnownClusterBlast network into its parts:</p> <p>Next, we will filter the BiG-FAM hits based on the top taxa distribution in the BiG-FAM database:</p> <p>Once we cleaned up the subgraphs, we then recombine them all again:</p> <p>Finally, we will add the metadata of the ARTS2 hits for prioritization:</p> <p>This table are then loaded as the node information for the graph:</p> <p>Followed by some sanitazion:</p> <p>And now, the graph is ready and can be downloaded for display in network visualization tools:</p> <pre># cd to the docs folder containing this notebook\njupyter nbconvert --to markdown \\\n    --execute \"custom_tutorial.ipynb\" \\\n    --output \"custom_tutorial.md\" \\\n    --template \"admonition\" \\\n    --TemplateExporter.extra_template_basedirs=\"../../../../workflow/notebook/nb_convert\"\n</pre> <p>You can also use the <code>--no-input</code> flag if you don't want to show the code cells.</p> <p>Then, add the Markdown file to the <code>mkdocs.yaml</code> navigation:</p> <pre>extra:\n  social:\n  - icon: fontawesome/brands/twitter\n    link: https://twitter.com/NPGMgroup\n  - icon: fontawesome/brands/github\n    link: https://github.com/NBChub/bgcflow\nmarkdown_extensions:\n- attr_list\n- admonition\n- pymdownx.details\n- pymdownx.superfences\nnav:\n- Home: index.md\n- QC and Data Selection:\n  - seqfu: seqfu.md\n  - mash: mash.md\n  - fastani: fastani.md\n  - checkm: checkm.md\n- Functional Annotation:\n  - prokka-gbk: prokka-gbk.md\n  - deeptfactor: deeptfactor.md\n- Genome Mining:\n  - antismash: antismash.md\n  - query-bigslice: query-bigslice.md\n  - bigscape: bigscape.md\n  - bigslice: bigslice.md\n  - arts: arts.md\n  - cblaster-genome: cblaster-genome.md\n  - cblaster-bgc: cblaster-bgc.md\n- Phylogenomic Placement:\n  - automlst-wrapper: automlst-wrapper.md\n- Comparative Genomics:\n  - roary: roary.md\n  - eggnog-roary: eggnog-roary.md\n- Custom Reports:\n  - How to Add Custom Analysis to the BGCFlow Report: custom_tutorial.md\ntheme:\n  icon:\n    admonition:\n      note: octicons/tag-16\n      code: material/code-tags\n...\n</pre> <p>Once you updated the <code>mkdocs.yaml</code> file, the site will be regenerated to show your newly added report. The report can be opened here http://localhost:8001/custom_tutorial/</p>"},{"location":"custom_tutorial/#prerequisites","title":"Prerequisites\u00b6","text":"<p>This tutorial utilizes the example dataset used in the BGCFlow manuscript</p> <p>To run this tutorial, you will need to finish the <code>mq_saccharopolyspora</code> run and build the report.</p> <p>MQ_Saccharopolyspora Project Configuration{:target=\"_blank\" .md-button}</p> <p>Create a new project configuration folder in the <code>config</code> folder and copy all the necessary project files there. Then run and build the report as follows:</p>"},{"location":"custom_tutorial/#default-conda-environments-for-the-notebooks","title":"Default conda environments for the notebooks\u00b6","text":"<p>When you run <code>bgcflow build report</code>, you can actually see which conda environments are being used <code>Snakemake</code> to generate the report. You can either use this existing environments, or set it up on your own from the recipe.</p> <p>There are two environments that BGCFlow used to make reports, a <code>Python</code> and a mix of <code>R</code> and <code>Python</code> environment:</p> <ul> <li>Python - bgcflow_notes.yaml</li> <li>R - r_notebook.yaml</li> </ul> <p>You can install the conda environments using those yaml file by:</p> <pre># use conda or mamba\nmamba env create -f bgcflow_notes.yaml # or r_notebook.yaml\n</pre>"},{"location":"custom_tutorial/#adding-a-new-notebook-to-the-analysis","title":"Adding a new notebook to the analysis\u00b6","text":""},{"location":"custom_tutorial/#tutorial-1-using-tables-to-filter-and-identify-unique-polyketide-bgcs","title":"Tutorial 1: Using Tables to Filter and Identify Unique Polyketide BGCs\u00b6","text":"<p>In this notebook, we aim to identify unique polyketide biosynthetic gene clusters (BGCs) that do not have hits in BigFam or MIBiG databases but have been identified in ARTS. This analysis can be used as the first step in the exploratory analysis of discovering potentially novel polyketide BGCs with unique functions.</p>"},{"location":"custom_tutorial/#setting-up-libraries-and-environment-variables","title":"Setting up libraries and environment variables\u00b6","text":"<p>We will start by use Python and pandas for data manipulation and filtering.</p>"},{"location":"custom_tutorial/#setting-up-input-files","title":"Setting up input files\u00b6","text":"<p>First, we need to find all the necessary tables or files required for our analysis. Here, we will need the results from antiSMASH, BiG-SCAPE, BiG-FAM query, and also ARTS2.</p> <p>Most of the tables can be found in the <code>tables</code> folder, such as the antiSMASH summary region tables:</p>"},{"location":"custom_tutorial/#using-pandas-and-itables-to-show-tables-interactively","title":"Using pandas and itables to show tables interactively\u00b6","text":""},{"location":"custom_tutorial/#exploratory-data-analysis","title":"Exploratory Data Analysis\u00b6","text":""},{"location":"custom_tutorial/#conclusion-for-tutorial-1","title":"Conclusion for Tutorial 1\u00b6","text":""},{"location":"custom_tutorial/#tutorial-2-exploring-integrated-network","title":"Tutorial 2: Exploring Integrated Network\u00b6","text":"<p>In the previous tutorial, we have shown how to create a custom notebook, explore, and filter the data using tables generated by BGCFlow.</p> <p>In this notebook, we will do an integrated analysis utilizing networks of knowledge bases from different tools: <code>BiG-SCAPE</code>, <code>antiSMASH KnownClusterBlast</code>, <code>BiG-FAM database query</code>, and <code>ARTS2</code>. We will generate a <code>graphml</code> file with annotation that can be loaded to Cytoscape and also also attempt to visualize the network in this notebook.</p>"},{"location":"custom_tutorial/#handling-graphs-reading-filtering-and-merging-networks","title":"Handling Graphs: Reading, Filtering, and Merging Networks\u00b6","text":"<p>We will start by defining some parameters for filtering:</p>"},{"location":"custom_tutorial/#network-visualization","title":"Network Visualization\u00b6","text":"<p>While we recommend users to use Network Visualization tools such as Cytoscape or Gephi, we can also attempt to visualize the network in Python</p>"},{"location":"custom_tutorial/#adding-adjacency-edge","title":"Adding adjacency edge\u00b6","text":"<p>If you have a high quality (complete) genomes, it might be interesting to see the position of each BGC regions relative to each other in a genome. Unfortunately, there are limited physics-based layout algorithm in python, so it is better to use Cytoscape or Gephi to visualize the network</p>"},{"location":"custom_tutorial/#displaying-the-notebook-in-the-report","title":"Displaying the notebook in the report\u00b6","text":"<p>To display this notebook in the HTML report, we need to convert this notebook into a Markdown file.</p> <p>First, we need to serve BGCFlow report this command:</p> <pre>bgcflow serve --project &lt;project name&gt;\n</pre> <p>The report will be served locally in http://localhost:8001/</p> <p>Then, to generate the Markdown use NBConvert in the terminal:</p>"},{"location":"custom_tutorial/","title":"Custom tutorial","text":"<p>This tutorial aims to show the flexibility of modifying, or generating markdown reports from BGCFlow template notebooks.</p> <p>We will go through a simple analysis of filtering results from different genome mining tools and finding our BGC of interest.</p>"},{"location":"custom_tutorial/#prerequisites","title":"Prerequisites","text":"<p>This tutorial utilizes the example dataset used in the BGCFlow manuscript</p> <p>To run this tutorial, you will need to finish the <code>mq_saccharopolyspora</code> run and build the report.</p> <p>MQ_Saccharopolyspora Project Configuration</p> <p>Create a new project configuration folder in the <code>config</code> folder and copy all the necessary project files there. Then run and build the report as follows:</p> <pre><code># Finish running BGCFlow\nbgcflow run\n\n# Build the report\nbgcflow build report\n</code></pre> <p>Once the run finishes, check the result in the processed directory (<code>data/processed/mq_saccharopolyspora</code>), it should generate a folder structure similar to this: </p> <pre><code>.\n\u251c\u2500\u2500 antismash\n\u251c\u2500\u2500 bigscape\n\u251c\u2500\u2500 bigslice\n\u251c\u2500\u2500 data_warehouse\n\u251c\u2500\u2500 docs\n\u2502   \u251c\u2500\u2500 antismash.ipynb\n\u2502   \u251c\u2500\u2500 antismash.md\n\u2502   \u251c\u2500\u2500 arts.ipynb\n\u2502   \u251c\u2500\u2500 arts.md\n\u2502   \u251c\u2500\u2500 assets\n\u2502   \u251c\u2500\u2500 bigscape.ipynb\n\u2502   \u251c\u2500\u2500 bigscape.md\n\u2502   \u251c\u2500\u2500 index.md\n\u2502   \u251c\u2500\u2500 query-bigslice.ipynb\n\u2502   \u2514\u2500\u2500 query-bigslice.md\n\u251c\u2500\u2500 log_changes\n\u251c\u2500\u2500 main.py\n\u251c\u2500\u2500 metadata\n\u251c\u2500\u2500 mkdocs.yml\n\u251c\u2500\u2500 overrides\n\u251c\u2500\u2500 README.md\n\u2514\u2500\u2500 tables\n</code></pre> <p>BGCFlow contains a starter Jupyter notebook template, generated in the <code>docs</code> folder, which are then converted to a <code>markdown</code> file, which can be used by <code>mkdocs</code> to generate a static HTML site. </p> <p>For more details about customizing the HTML report, see https://squidfunk.github.io/mkdocs-material/</p>"},{"location":"custom_tutorial/#default-conda-environments-for-the-notebooks","title":"Default conda environments for the notebooks","text":"<p>When you run <code>bgcflow build report</code>, you can actually see which conda environments are being used <code>Snakemake</code> to generate the report. You can either use this existing environments, or set it up on your own from the recipe.</p> <p>There are two environments that BGCFlow used to make reports, a <code>Python</code> and a mix of <code>R</code> and <code>Python</code> environment:</p> <ul> <li>Python - bgcflow_notes.yaml</li> <li>R - r_notebook.yaml</li> </ul> <p>You can install the conda environments using those yaml file by:</p> <pre><code># use conda or mamba\nmamba env create -f bgcflow_notes.yaml # or r_notebook.yaml\n</code></pre>"},{"location":"custom_tutorial/#adding-a-new-notebook-to-the-analysis","title":"Adding a new notebook to the analysis","text":"<p>To add your own analysis, you can start up Jupyter session using the environments above, and create a new notebook inside the <code>docs</code> folder. You can also download this notebook tutorial here:</p> <p>Download Notebook</p> <p>Let's give our notebook the name <code>custom_tutorial.ipynb</code></p>"},{"location":"custom_tutorial/#tutorial-1-using-tables-to-filter-and-identify-unique-polyketide-bgcs","title":"Tutorial 1: Using Tables to Filter and Identify Unique Polyketide BGCs","text":"<p>In this notebook, we aim to identify unique polyketide biosynthetic gene clusters (BGCs) that do not have hits in BigFam or MIBiG databases but have been identified in ARTS. This analysis can be used as the first step in the exploratory analysis of discovering potentially novel polyketide BGCs with unique functions. </p>"},{"location":"custom_tutorial/#setting-up-libraries-and-environment-variables","title":"Setting up libraries and environment variables","text":"<p>We will start by use Python and pandas for data manipulation and filtering.</p> <p>First, let's import the necessary Python libraries and define the directory containing our report data.</p> <p>??? code \"Code\"     ```python     from pathlib import Path     import json     import pandas as pd</p> <pre><code>from IPython.display import display, Markdown, HTML\n\nfrom itables import to_html_datatable as DT\nimport itables.options as opt\n\nopt.css = \"\"\"\n.itables table td { font-style: italic; font-size: .8em;}\n.itables table th { font-style: oblique; font-size: .8em; }\n\"\"\"\n\nopt.classes = [\"display\", \"compact\"]\nopt.lengthMenu = [5, 10, 20, 50, 100, 200, 500]\n\n# Define the directory containing the report\nreport_directory = Path(\"../\")\n```\n</code></pre> <p>Note from the code that the report directory is located one directory above of this notebook (which is located in the <code>docs</code> folder)</p> <p>The <code>metadata</code> folder records some of the important software versions and also other information of the BGCFlow runs. First, we will fetch the <code>antiSMASH</code> version used in the run from the metadata.</p> <p>??? code \"Code\"     ```python     # Load the dependency versions     dependency_versions_file = report_directory / \"metadata/dependency_versions.json\"     with open(dependency_versions_file, \"r\") as file:         dependency_versions = json.load(file)</p> <pre><code># Extract the version of antiSMASH used\nantismash_version = dependency_versions[\"antismash\"]\n\ndisplay(Markdown(f\"&gt; antiSMASH version is: `{antismash_version}`\"))\n```\n</code></pre> <p>antiSMASH version is: <code>7.1.0</code></p>"},{"location":"custom_tutorial/#setting-up-input-files","title":"Setting up input files","text":"<p>First, we need to find all the necessary tables or files required for our analysis. Here, we will need the results from antiSMASH, BiG-SCAPE, BiG-FAM query, and also ARTS2.</p> <p>Most of the tables can be found in the <code>tables</code> folder, such as the antiSMASH summary region tables:</p> <p>??? code \"Code\"     <code>python     # Define the paths to the input files     antismash_regions_file = report_directory / f\"tables/df_regions_antismash_{antismash_version}.csv\"     display(Markdown(f\"&gt;`{antismash_regions_file}`\"))</code></p> <p><code>../tables/df_regions_antismash_7.1.0.csv</code></p> <p>Some other tables are located in their specific directories, such BiG-SCAPE</p> <p>??? code \"Code\"     ```python     # Define the directory containing the BIG-SCAPE data     bigscape_directory = report_directory / f\"bigscape/for_cytoscape_antismash_{antismash_version}/\"</p> <pre><code># Find the cluster table file\ncluster_table_file = [i for i in bigscape_directory.glob(\"*_df_clusters_0.30.csv\")][0]\ndisplay(Markdown(f\"&gt;`{cluster_table_file}`\"))\n```\n</code></pre> <p><code>../bigscape/for_cytoscape_antismash_7.1.0/2024-04-22 20_44_19_df_clusters_0.30.csv</code></p> <p>??? code \"Code\"     <code>python     # Define the directory containing the query data     bigfam_query = report_directory / f\"bigslice/query_as_{antismash_version}/query_network.csv\"     display(Markdown(f\"&gt;`{bigfam_query}`\"))</code></p> <p><code>../bigslice/query_as_7.1.0/query_network.csv</code></p> <p>Other tables are created by the Jupyter notebook templates, and usually can be interactively downloaded from the HTML report. By convention, this are stored in the <code>assets</code> directory within the <code>docs</code> folder. </p> <p>??? code \"Code\"     <code>python     arts_table_file = Path(f\"assets/tables/arts_hits_as{antismash_version}.csv\")     display(Markdown(f\"&gt;`{arts_table_file}`\"))</code></p> <p><code>assets/tables/arts_hits_as7.1.0.csv</code></p>"},{"location":"custom_tutorial/#using-pandas-and-itables-to-show-tables-interactively","title":"Using pandas and itables to show tables interactively","text":"<p>While pandas can show nice summary of a table, it does not do so interactively, and does not render well in the HTML report. We can use itables to display our tables as interactive datatables that we can sort, paginate, scroll or filter. To enable this feature in the final report, we are converting the tables to HTML datatables and displaying it with iPython.</p> <p>??? code \"Code\"     ```python     # Load the data from the input files     df_antismash_regions = pd.read_csv(antismash_regions_file)     # Correct similarity values and fill null values with 0     df_antismash_regions[\"similarity\"] = df_antismash_regions[\"similarity\"].apply(lambda x: 1 if x &gt; 1 else x).fillna(0)</p> <pre><code>df_bigscape = pd.read_csv(cluster_table_file)\ndf_arts_hits = pd.read_csv(arts_table_file)\ndf_bigfam_hits = pd.read_csv(bigfam_query )\n```\n</code></pre> <p>??? code \"Code\"     <code>python     display(Markdown(f\"&gt;`{antismash_regions_file}`\"))     display(HTML(DT(df_antismash_regions, scrollX=True)))</code></p> <p><code>../tables/df_regions_antismash_7.1.0.csv</code></p> bgc_id genome_id region accession start_pos end_pos contig_edge product region_length most_similar_known_cluster_id most_similar_known_cluster_description most_similar_known_cluster_type similarity source gbk_path Loading... (need help?) <p>??? code \"Code\"     <code>python     display(Markdown(f\"&gt;`{cluster_table_file}`\"))     display(HTML(DT(df_bigscape, scrollX=True)))</code></p> <p><code>../bigscape/for_cytoscape_antismash_7.1.0/2024-04-22 20_44_19_df_clusters_0.30.csv</code></p> bgc_id product bigscape_class genome_id accn_id gcf_0.30 gcf_0.40 gcf_0.50 Clan Number fam_id_0.30 fam_type_0.30 fam_known_compounds_0.30 Loading... (need help?) <p>??? code \"Code\"     <code>python     display(Markdown(f\"&gt;`{arts_table_file}`\"))     display(HTML(DT(df_arts_hits, scrollX=True)))</code></p> <p><code>assets/tables/arts_hits_as7.1.0.csv</code></p> pkey profile genome_id name product start stop strand scaffold sequence_id type transl_table core_table_fkey Dup HGT Res bgc_id gene description function bgctable_fkey BGC duptable_fkey evalue bitscore gid seqtitle hits Loading... (need help?) <p>??? code \"Code\"     <code>python     display(Markdown(f\"&gt;`{bigfam_query}`\"))     display(HTML(DT(df_bigfam_hits, scrollX=True)))</code></p> <p><code>../bigslice/query_as_7.1.0/query_network.csv</code></p> gcf_id bgc_id membership_value rank Loading... (need help?) <p>Note that these tables are downsampled by default to prevent the Markdown report become heavy. See https://mwouts.github.io/itables/downsampling.html for more details. </p> <p>We do not recommend to use the HTML reports to show big tables as it's purpose is to give a quick summary of the analysis.</p>"},{"location":"custom_tutorial/#exploratory-data-analysis","title":"Exploratory Data Analysis","text":"<p>BiG-SCAPE filtering</p> <p>Let's start by looking at the BiG-SCAPE category of unknown PKS. We will create a filtering following this logic:</p> <ul> <li> <p>Define Classes to Filter By: We will select all possible PKS categories in BiG-SCAPE and put it in a list named bigscape_class, containing PKSI, PKSother, and PKS-NRP_Hybrids. To see all available bigscape_class, do: <code>df_bigscape[\"bigscape_class\"].unique()</code></p> </li> <li> <p>Filter for unknown families: The column <code>fam_type_0.30</code> defines whether the BGCs belongs to a known or unknown GCFs using the cutoff value of 0.3. We will set the string variable family_type to \"unknown_family\", which then used to filter rows based on a column in the DataFrame related to family types.</p> </li> <li> <p>Create Masks for Filtering:</p> <ul> <li> <p>mask1: This is a boolean mask created by checking if the values in the column fam_type_0.30 of df_bigscape are equal to family_type (\"unknown_family\"). This mask is true for rows where the family type is unknown.</p> </li> <li> <p>mask2: This is another boolean mask created by checking if the values in the column bigscape_class are within the list bigscape_class defined at the start. This mask is true for rows that match any of the specified classes (PKSI, PKSother, PKS-NRP_Hybrids).</p> </li> </ul> </li> <li> <p>Filter DataFrame: The DataFrame df_bigscape is filtered using the logical AND (&amp;) of mask1 and mask2. This means only rows where both conditions are true (i.e., the family type is \"unknown_family\" and the bigscape class is one of the specified classes) are selected.</p> </li> </ul> <p>??? code \"Code\"     <code>python     bigscape_class = ['PKSI', 'PKSother', 'PKS-NRP_Hybrids']     family_type = \"unknown_family\"     mask1 = df_bigscape[\"fam_type_0.30\"] == family_type     mask2 = df_bigscape[\"bigscape_class\"].isin(bigscape_class)     df_bigscape_PKS_unknown = df_bigscape[mask1 &amp; mask2]     display(HTML(DT(df_bigscape_PKS_unknown, scrollX=True)))</code></p> bgc_id product bigscape_class genome_id accn_id gcf_0.30 gcf_0.40 gcf_0.50 Clan Number fam_id_0.30 fam_type_0.30 fam_known_compounds_0.30 Loading... (need help?) <p>??? code \"Code\"     ```python     number_of_gcf = len(df_bigscape_PKS_unknown[\"fam_id_0.30\"].unique())</p> <pre><code>text = f\"\"\"We found {df_bigscape.shape[0]} BGC regions in the category of {', '.join(bigscape_class)} which belongs to {family_type.replace('_', ' ')}.\\\n These BGCs can be grouped into {len(df_bigscape_PKS_unknown[\"fam_id_0.30\"].unique())} GCFs.\"\"\"\nMarkdown(text)\n```\n</code></pre> <p>We found 739 BGC regions in the category of PKSI, PKSother, PKS-NRP_Hybrids which belongs to unknown family. These BGCs can be grouped into 70 GCFs.</p> <p>AntiSMASH KnownClusterBlast filtering</p> <p>We will now look at the KnownClusterBlast similarity score and decide if we need to further filter our search. We will subset the antiSMASH BGC regions table to only contains BGCs identified in the previous step and observe the KnownClusterBlast similarity values. We will narrow down our search by setting up a threshold for the similarity score.</p> <p>??? code \"Code\"     <code>python     # Extract the BGC IDs of the unknown families     unknown_family_bgcs = df_bigscape_PKS_unknown.bgc_id.to_list()</code></p> <p>??? code \"Code\"     <code>python     mask_unknown_family = df_antismash_regions.bgc_id.isin(unknown_family_bgcs)     columns_to_show = [\"bgc_id\", \"genome_id\", \"product\", \"similarity\",                         \"most_similar_known_cluster_id\", \"most_similar_known_cluster_description\", \"region\", \"contig_edge\", \"region_length\", ]     display(HTML(DT(df_antismash_regions[mask_unknown_family].loc[:, columns_to_show], scrollX=True)))</code></p> bgc_id genome_id product similarity most_similar_known_cluster_id most_similar_known_cluster_description region contig_edge region_length Loading... (need help?) <p>??? code \"Code\"     <code>python     similarity_cutoff = 0.30     mask_similarity = df_antismash_regions.similarity &lt; similarity_cutoff     text2 = f\"From those **{df_antismash_regions[mask_unknown_family].shape[0]} BGCs**, we actually still have a few BGCs with high similarity based on KnownClusterBlast.\\      Let us focus on BGCs with low similarity **(&lt;{similarity_cutoff})**, and now we are left with **{df_antismash_regions[mask_unknown_family &amp; mask_similarity].shape[0]} BGCs**.\"     Markdown(text2)</code></p> <p>From those 123 BGCs, we actually still have a few BGCs with high similarity based on KnownClusterBlast. Let us focus on BGCs with low similarity (&lt;0.3), and now we are left with 67 BGCs.</p> <p>??? code \"Code\"     <code>python     display(HTML(DT(df_antismash_regions[mask_unknown_family &amp; mask_similarity].loc[:, columns_to_show], scrollX=True)))</code></p> bgc_id genome_id product similarity most_similar_known_cluster_id most_similar_known_cluster_description region contig_edge region_length Loading... (need help?) <p>BiG-FAM query filtering</p> <p>We will also remove all BGCs that has a match to other BGCs in the BiG-FAM database.</p> <p>??? code \"Code\"     <code>python     mask_no_bigfam_hit = ~df_antismash_regions.bgc_id.isin(df_bigfam_hits.bgc_id.unique())     display(HTML(DT(df_antismash_regions[mask_unknown_family &amp; mask_similarity &amp; mask_no_bigfam_hit].loc[:, columns_to_show], scrollX=True)))</code></p> bgc_id genome_id product similarity most_similar_known_cluster_id most_similar_known_cluster_description region contig_edge region_length Loading... (need help?) <p>ARTS hits filtering</p> <p>We will now select only BGCs with close proximity to one of the ARTS2 model. Note that ARTS2 actually have several criteria to prioritise BGCs with possible antibiotic activity, here we just search for all BGCs that has hits to ARTS2 profile.</p> <p>??? code \"Code\"     <code>python     mask_arts_hit = df_antismash_regions.bgc_id.isin(df_arts_hits.bgc_id.dropna().unique())     df_pks_filtered = df_antismash_regions[mask_unknown_family &amp; mask_similarity &amp; mask_no_bigfam_hit &amp; mask_arts_hit]     display(HTML(DT(df_pks_filtered.loc[:, columns_to_show], scrollX=True)))</code></p> bgc_id genome_id product similarity most_similar_known_cluster_id most_similar_known_cluster_description region contig_edge region_length Loading... (need help?)"},{"location":"custom_tutorial/#conclusion-for-tutorial-1","title":"Conclusion for Tutorial 1","text":"<p>??? code \"Code\"     <code>python     text3 = f\"We are now left with **{df_pks_filtered.shape[0]} PKS BGCs** of interest which can be further invesigated in-depth.\"     Markdown(text3)</code></p> <p>We are now left with 15 PKS BGCs of interest which can be further invesigated in-depth.</p> <p>This tutorial help us narrow down our search to potentially novel PKS. Nevertheless, an in-depth investigation to the BGC structure and see if it has all the required genes to perform natural product biosynthesis.</p> <p>We also recommend users to try out <code>Metabase</code> for a more interactive experience of exploring the datasets. See the how to guide in our WiKi</p>"},{"location":"custom_tutorial/#tutorial-2-exploring-integrated-network","title":"Tutorial 2: Exploring Integrated Network","text":"<p>In the previous tutorial, we have shown how to create a custom notebook, explore, and filter the data using tables generated by BGCFlow.</p> <p>In this notebook, we will do an integrated analysis utilizing networks of knowledge bases from different tools: <code>BiG-SCAPE</code>, <code>antiSMASH KnownClusterBlast</code>, <code>BiG-FAM database query</code>, and <code>ARTS2</code>. We will generate a <code>graphml</code> file with annotation that can be loaded to Cytoscape and also also attempt to visualize the network in this notebook.</p> <p>??? code \"Code\"     ```python     import pandas as pd     import networkx as nx     from pathlib import Path     import json     import numpy as np     import plotly.graph_objects as go     import seaborn as sns     from IPython.display import display, Markdown, HTML</p> <pre><code>from itables import to_html_datatable as DT\nimport itables.options as opt\n\nopt.css = \"\"\"\n.itables table td { font-style: italic; font-size: .8em;}\n.itables table th { font-style: oblique; font-size: .8em; }\n\"\"\"\n\nopt.classes = [\"display\", \"compact\"]\nopt.lengthMenu = [5, 10, 20, 50, 100, 200, 500]\n\ndef create_node_trace(G, node_trace_category, color, showtextlabel=False, nodesize=10, nodeopacity=0.8, \n                      nodesymbol=\"circle\", linewidth=1, linecolor=\"black\", textposition=\"top center\", showlegend=False):\n    \"\"\"\n    Create a node trace for a given graph.\n\n    Parameters:\n    G (networkx.Graph): The graph to create the node trace for.\n    node_trace_category (str): The category of the node trace.\n    color (str): The color of the nodes.\n    showtextlabel (bool): Whether to show text labels for the nodes.\n    nodesize (int): The size of the nodes.\n    nodeopacity (float): The opacity of the nodes.\n    nodesymbol (str): The symbol used for the nodes.\n    linewidth (int): The width of the lines.\n    linecolor (str): The color of the lines.\n    textposition (str): The position of the text labels.\n    showlegend (bool): Whether to show the legend.\n\n    Returns:\n    go.Scatter: The node trace.\n    \"\"\"\n    if showtextlabel:\n        markermode = \"markers+text\"\n    else:\n        markermode = \"markers\"\n    nodes = np.array([node for node in G.nodes() if G.nodes[node][\"node_trace\"] == node_trace_category])\n    pos = np.array([G.nodes[node]['pos'] for node in nodes.flatten()]).reshape(-1, 2)\n    xs, ys = pos[:, 0], pos[:, 1]\n    texts = np.array([G.nodes[node]['text'] for node in nodes if \"text\" in G.nodes[node].keys()])\n    node_trace = go.Scatter(\n        x=xs.tolist(),\n        y=ys.tolist(),\n        text=texts.tolist(),\n        textposition=textposition,\n        mode=markermode,\n        hoverinfo='text',\n        name=node_trace_category,\n        showlegend=showlegend,\n        marker=dict(\n            symbol=nodesymbol,\n            opacity=nodeopacity,\n            showscale=False,\n            color=color,\n            size=nodesize,\n            line=dict(width=linewidth, color=linecolor)))\n    return node_trace\n\ndef create_edge_trace(Graph, name, showlegend=False, color='#888', width=0.5, opacity=0.8, dash=\"solid\"):\n    \"\"\"\n    Create an edge trace for a given graph.\n\n    Parameters:\n    Graph (networkx.Graph): The graph to create the edge trace for.\n    name (str): The name of the edge trace.\n    showlegend (bool): Whether to show the legend.\n    color (str): The color of the edges.\n    width (float): The width of the edges.\n    opacity (float): The opacity of the edges.\n    dash (str): The style of the edges.\n\n    Returns:\n    go.Scatter: The edge trace.\n    \"\"\"\n    edge_trace = go.Scatter(\n        x=[],\n        y=[],\n        name=name,\n        opacity=opacity,\n        line=dict(width=width,color=color, dash=dash),\n        hoverinfo='none',\n        mode='lines',\n        showlegend=showlegend)\n\n    edges = np.array([edge for edge in Graph.edges() if G.edges[edge][\"relation_type\"] == name])\n    pos = np.array([Graph.nodes[e]['pos'] for e in edges.flatten()]).reshape(-1, 2)\n    xs = np.insert(pos[:, 0], np.arange(2, len(pos[:, 0]), 2), None)\n    ys = np.insert(pos[:, 1], np.arange(2, len(pos[:, 1]), 2), None)\n    edge_trace['x'] = xs\n    edge_trace['y'] = ys\n\n    return edge_trace\n\ndef get_graph_stats(g, graph_name):\n    \"\"\"\n    Get statistics for a given graph.\n\n    Parameters:\n    g (networkx.Graph): The graph to get statistics for.\n    graph_name (str): The name of the graph.\n\n    Returns:\n    str: A string containing the statistics for the graph.\n    \"\"\"\n    num_nodes_g = g.number_of_nodes()\n    num_edges_g = g.number_of_edges()\n    avg_degree_g = sum(dict(g.degree()).values()) / num_nodes_g\n    num_bgc_g = sum(1 for _, data in g.nodes(data=True) if data.get('node_trace') == 'BGC')\n    return f\" - {graph_name} : **{num_nodes_g}** total nodes (**{num_bgc_g}** BGC nodes), **{num_edges_g}** edges, {avg_degree_g:.2f} average degree\"\n```\n</code></pre>"},{"location":"custom_tutorial/#handling-graphs-reading-filtering-and-merging-networks","title":"Handling Graphs: Reading, Filtering, and Merging Networks","text":"<p>We will start by defining some parameters for filtering:</p> <p>??? code \"Code\"     <code>python     bigscape_cutoff = \"0.30\"     bigfam_rank_filter = 1 # only select first hits of bigfam models     knownclusterblast_similarity_cutoff = 0.8 # select antismash knownclusterblast hits above 0.7</code></p> <p>And then we will first list all the files that we need:</p> <p>??? code \"Code\"     ```python     report_dir = Path(\"../\")     dependency_version = report_dir / \"metadata/dependency_versions.json\"     with open(dependency_version, \"r\") as file:         dependency_version = json.load(file)</p> <pre><code>antismash_version = dependency_version[\"antismash\"]\n\nassets_dir = report_dir / \"docs/assets\"\nintegrated_bigscape_network = assets_dir / f\"data/bigscape_{bigscape_cutoff}_as{antismash_version}.graphml\"\nbigfam_network = assets_dir / f\"data/query_bigfam_as{antismash_version}_network.json\"\narts_hits = assets_dir / f\"tables/arts_hits_as{antismash_version}.csv\"\n```\n</code></pre> <p>We will start by reading the input files into memory:</p> <p>??? code \"Code\"     ```python     # read ARTS table     df_arts_hits = pd.read_csv(arts_hits)</p> <pre><code>integrated_bigscape_network_graph = nx.read_graphml(integrated_bigscape_network)\n\n# Iterate over the nodes of bigscape_network_graph_knownclusterblast\nfor n, data in integrated_bigscape_network_graph.nodes(data=True):\n    # If node_trace is not in the node's attributes, add it with a default value\n    if 'node_trace' not in data:\n        if n.startswith('BGC'):\n            integrated_bigscape_network_graph.nodes[n]['node_trace'] = 'MIBIG_BiG-SCAPE'\n        else:\n            integrated_bigscape_network_graph.nodes[n]['node_trace'] = 'BGC'\n\nwith open(bigfam_network, \"r\") as f:\n    graph_data = json.load(f)\n    bigfam_network_graph = nx.readwrite.json_graph.node_link_graph(graph_data)\n\nfor n, data in bigfam_network_graph.nodes(data=True):\n    bigfam_network_graph.nodes[n]['node_trace'] = bigfam_network_graph.nodes[n]['node_type']\n\nbigfam_network_graph = nx.relabel_nodes(bigfam_network_graph, lambda x: str(x))\n```\n</code></pre> <p>And then continue by filtering the networks based on our cutoff definition.</p> <p>In this first part, we will split again the BiG-SCAPE - antiSMASH KnownClusterBlast network into its parts:</p> <p>??? code \"Code\"     ```python     # Filter edges with relation_type = 'bigscape_similarity'     edges_with_bigscape_similarity = [(u, v) for u, v, d in integrated_bigscape_network_graph.edges(data=True) if d['relation_type'] == 'bigscape_similarity']</p> <pre><code># Filter edges with relation_type = 'knownclusterblast' and similarity above the threshold\nedges_with_knownclusterblast = [(u, v) for u, v, d in integrated_bigscape_network_graph.edges(data=True) if d['relation_type'] == 'knownclusterblast' and d['similarity'] &gt; knownclusterblast_similarity_cutoff]\n\n# Create subgraph\nbigscape_network_graph_knownclusterblast = integrated_bigscape_network_graph.edge_subgraph(edges_with_knownclusterblast)\nbigscape_network_graph_bigscape_similarity = integrated_bigscape_network_graph.edge_subgraph(edges_with_bigscape_similarity)\n\n# Calculate stats for bigscape_network_graph\ndisplay(Markdown(get_graph_stats(integrated_bigscape_network_graph, \"integrated_bigscape_network_graph\")))\n\n# Calculate stats for bigscape_network_graph_knownclusterblast\ndisplay(Markdown(get_graph_stats(bigscape_network_graph_knownclusterblast, f\"bigscape_network_graph_knownclusterblast with similarity &gt; {knownclusterblast_similarity_cutoff}\")))\n\n# Calculate stats for bigscape_network_graph_bigscape_similarity\ndisplay(Markdown(get_graph_stats(bigscape_network_graph_bigscape_similarity, \"bigscape_network_graph_bigscape_similarity\")))\n```\n</code></pre> <ul> <li> <p>integrated_bigscape_network_graph : 898 total nodes (739 BGC nodes), 1809 edges, 4.03 average degree</p> </li> <li> <p>bigscape_network_graph_knownclusterblast with similarity &gt; 0.8 : 156 total nodes (135 BGC nodes), 135 edges, 1.73 average degree</p> </li> <li> <p>bigscape_network_graph_bigscape_similarity : 740 total nodes (737 BGC nodes), 1201 edges, 3.25 average degree</p> </li> </ul> <p>Next, we will filter the BiG-FAM hits based on the top taxa distribution in the BiG-FAM database:</p> <p>??? code \"Code\"     ```python     bigfam_models_stats = pd.DataFrame.from_dict({n:data for n, data in bigfam_network_graph.nodes(data=True) if data[\"node_trace\"] != \"BGC\"}).T</p> <pre><code>deleted_bigfam = []\nbigfam_taxa_cutoff = 0.3\nbigfam_filter = bigfam_models_stats[bigfam_models_stats.top_taxa_proportion &lt;= bigfam_taxa_cutoff]\nfor n in bigfam_filter.index:\n    try:\n        bigfam_network_graph.remove_node(n)\n        deleted_bigfam.append(n)  \n    except nx.NetworkXError as e:\n        print(e)\n\ndeleted_bigfam = ', '.join([str(i) for i in deleted_bigfam])\ndisplay(Markdown(f\"Deleted BigFam models: {deleted_bigfam}\"))\n```\n</code></pre> <p>Deleted BigFam models: 202087, 203037, 210179, 213140, 208355, 202433, 225711, 201637, 201682, 201608, 202162, 205957, 215277, 202082, 200980, 201592, 218961, 227201, 201830, 201902</p> <p>??? code \"Code\"     ```python     # Filter edges with rank = 0     edges_with_rank_filtered = [(u, v) for u, v, d in bigfam_network_graph.edges(data=True) if d['rank'] &lt; bigfam_rank_filter]</p> <pre><code># Create subgraph\nbigfam_network_graph_filtered = bigfam_network_graph.edge_subgraph(edges_with_rank_filtered)\n# Iterate over the edges of bigfam_network_graph_filtered\nfor u, v, data in bigfam_network_graph_filtered.edges(data=True):\n    # Get the relation_type attribute\n    if \"relation_type\" not in data.keys():\n        data[\"relation_type\"] = \"bigfam_similarity\"\n\n# Calculate stats for bigfam_network_graph\ndisplay(Markdown(get_graph_stats(bigfam_network_graph, \"bigfam_network_graph\")))\n\n# Calculate stats for bigfam_network_graph_filtered\ndisplay(Markdown(get_graph_stats(bigfam_network_graph_filtered, \"bigfam_network_graph_filtered\")))\n```\n</code></pre> <ul> <li> <p>bigfam_network_graph : 470 total nodes (367 BGC nodes), 362 edges, 1.54 average degree</p> </li> <li> <p>bigfam_network_graph_filtered : 424 total nodes (331 BGC nodes), 331 edges, 1.56 average degree</p> </li> </ul> <p>Once we cleaned up the subgraphs, we then recombine them all again:</p> <p>??? code \"Code\"     <code>python     # Combine Graphs     G = nx.compose(bigscape_network_graph_bigscape_similarity, bigscape_network_graph_knownclusterblast)     G = nx.compose(G, bigfam_network_graph_filtered)     display(Markdown(get_graph_stats(G, \"integrated_graph\")))</code></p> <ul> <li>integrated_graph : 855 total nodes (739 BGC nodes), 1667 edges, 3.90 average degree</li> </ul> <p>Finally, we will add the metadata of the ARTS2 hits for prioritization:</p> <p>??? code \"Code\"     ```python     def custom_agg(x):         if x.dtypes == object:             return ', '.join(x)         else:             return x.sum()</p> <pre><code>df_arts_hits_filtered = df_arts_hits[(~df_arts_hits.bgc_id.isna()) &amp; (df_arts_hits.hits &gt; 1)].loc[:, [\"bgc_id\", \"profile\", \"hits\", \"Dup\", \"HGT\", \"Res\", \"BGC\"]]\ndf_arts_hits_filtered = df_arts_hits_filtered.apply(lambda x: x.map(lambda y: y.replace('\u2714', '1').replace('\u2716', '0') if isinstance(y, str) else y))\ndf_arts_hits_filtered = df_arts_hits_filtered.apply(lambda x: x.map(lambda y: int(y) if isinstance(y, str) and y.isdigit() else y))\ndf_arts_hits_filtered = df_arts_hits_filtered.groupby(\"bgc_id\").agg(custom_agg)\ndf_arts_hits_filtered = df_arts_hits_filtered.rename(columns={c:f\"ARTS_{c}\" for c in df_arts_hits_filtered.columns})\ndisplay(HTML(DT(df_arts_hits_filtered.reset_index(), scrollX=True)))\n```\n</code></pre> bgc_id ARTS_profile ARTS_hits ARTS_Dup ARTS_HGT ARTS_Res ARTS_BGC Loading... (need help?) <p>This table are then loaded as the node information for the graph:</p> <p>??? code \"Code\"     <code>python     for n in df_arts_hits_filtered.index:         for c in df_arts_hits_filtered.columns:             G.nodes[n][c] = df_arts_hits_filtered.loc[n, c]</code></p> <p>Followed by some sanitazion:</p> <p>??? code \"Code\"     ```python     # Get self-loops     self_loops = nx.selfloop_edges(G)</p> <pre><code># Check if there are any self-loops\nif self_loops is not None:\n    # Remove self-loops\n    G.remove_edges_from(self_loops)\n\n# Iterate over the nodes of the graph, getting the node and its attributes\nfor n, data in G.nodes(data=True):\n    # Create a list of keys to remove after iterating over the dictionary\n    keys_to_remove = []\n    # Iterate over the items in the attributes dictionary\n    for k, v in data.items():\n        # Check if the value is not of a type compatible with GraphML\n        if isinstance(v, list):\n            data[k] = \", \".join([str(i) for i in v])\n        elif v is None:\n            # Add the key to the list of keys to remove\n            keys_to_remove.append(k)\n        elif not isinstance(v, (int, float, str, bool, np.int64)):\n            print(f\"Node {n} has attribute {k} of incompatible type {type(v)}\")\n    # Remove the keys with None values\n    for key in keys_to_remove:\n        del G.nodes[n][key]\n```\n</code></pre> <p>And now, the graph is ready and can be downloaded for display in network visualization tools:</p> <p>??? code \"Code\"     <code>python     outfile = Path(f\"assets/integrated_network__bigscape_{bigscape_cutoff}__bigfam_{bigfam_rank_filter}__knownclusterblast_{knownclusterblast_similarity_cutoff}.graphml\")     outfile.parent.mkdir(parents=True, exist_ok=True)     nx.write_graphml(G, outfile)     display(Markdown(f\"[Download Graph]({str(outfile)})\"+'{:target=\"_blank\" .md-button}'))</code></p> <p>Download Graph</p>"},{"location":"custom_tutorial/#network-visualization","title":"Network Visualization","text":"<p>While we recommend users to use Network Visualization tools such as Cytoscape or Gephi, we can also attempt to visualize the network in Python</p> <p>??? code \"Code\"     ```python     # define layout options     options = {         'prog': 'twopi',         #'args': ' '.join(['-Gstart=10', '-Goverlap_scaling=-100'])     }</p> <pre><code># position nodes\npos = nx.nx_agraph.pygraphviz_layout(G, **options)#, args='-Goverlap=false -Elen=weight')\nfor n, p in pos.items():\n    G.nodes[n]['pos'] = p\n    # set up text display\n    node_trace = G.nodes[n][\"node_trace\"]\n    if \"text\" not in G.nodes[n].keys():\n        text = [n]\n        for k, v in G.nodes[n].items():\n            if node_trace == \"BGC\":\n                if k in [\"genome_id\", \"product\", \"bigscape_class\", \"Organism\"]:\n                    text.append(f\"{k} : {v}\")\n        text = \"&lt;br&gt;\".join(text)\n        G.nodes[n]['text'] = text\n\nbigscape_class_labels = set([data['bigscape_class'] for n, data in G.nodes(data=True) if data[\"node_trace\"] == \"BGC\"])\nbigscape_class_colors = sns.color_palette(\"colorblind\", len(bigscape_class_labels)).as_hex()\n\n# define visualization\nedge_annotation_map = {'bigscape_similarity' : {'color':'black',\n                                                'width':10\n                                               },\n                       'knownclusterblast' : {'color':'grey',\n                                                'width':0.1\n                                               },\n                       'bigfam_similarity' : {'color':'grey',\n                                                'width':0.1\n                                               },\n                      }\n\nnode_annotation_map = {'MIBIG_BiG-SCAPE' : {'color':'green',\n                                  'node_symbol' : 'star'},\n                       'MIBIG_knownclusterblast': {'color':'blue',\n                                  'node_symbol' : 'star'}, \n                       \"BGC\" : {'color':'grey',\n                                'node_symbol' : 'circle'},\n                       \"BiG-FAM GCFs\" : {'color':'yellow',\n                                'node_symbol' : 'triangle-up'},\n                      }\n```\n</code></pre> <p>??? code \"Code\"     ```python     traces = []     node_trace = []     edge_trace = []</p> <pre><code>for e in edge_annotation_map.keys():\n    dash = \"solid\"\n    if 'knownclusterblast' in e:\n        dash = \"dot\"\n    edge_trace = create_edge_trace(G, e, color=edge_annotation_map[e]['color'], dash=dash, showlegend=True)\n    traces.append(edge_trace)\n\nfor trace in node_annotation_map.keys():\n    nodeopacity = 0.5\n    showtextlabel = False\n    linecolor = \"black\"\n    linewidth = 0.5\n    textposition=\"top left\"\n    node_size = 8\n    if trace in bigscape_class_labels:\n        nodeopacity = 0.8\n    node_trace = create_node_trace(G, trace, node_annotation_map[trace]['color'], showtextlabel=showtextlabel, \n                                   nodesymbol=node_annotation_map[trace]['node_symbol'], nodeopacity=nodeopacity, \n                                   showlegend=True, linecolor=linecolor, linewidth=linewidth, nodesize=node_size,\n                                   textposition=textposition)\n    traces.append(node_trace)\n\nG_arts = G.copy()\nfor n in G_arts.nodes:\n    if n in df_arts_hits_filtered.index:\n        G_arts.nodes[n][\"node_trace\"] = \"ARTS_hits\"\n\nnodeopacity = 0.5\nshowtextlabel = False\nnode_symbol = \"circle\"\nnode_color = \"grey\"\nlinecolor = \"red\"\nlinewidth = 1\ntextposition=\"top left\"\nnode_size = 8\nnode_trace = create_node_trace(G_arts, \"ARTS_hits\", node_color, showtextlabel=showtextlabel, \n                                   nodesymbol=node_symbol, nodeopacity=nodeopacity, \n                                   showlegend=True, linecolor=linecolor, linewidth=linewidth, nodesize=node_size,\n                                   textposition=textposition)\n\ntraces.append(node_trace)\n\nfig = go.Figure(data=traces,\n                layout=go.Layout(\n                    paper_bgcolor='rgba(0,0,0,0)',\n                    plot_bgcolor='white',\n                    showlegend=True,\n                    hovermode='closest',\n                    margin=dict(b=20,l=5,r=5,t=40),\n                    xaxis=dict(showgrid=False, zeroline=False, showticklabels=False, linecolor='black', mirror=True, linewidth=1),\n                    yaxis=dict(showgrid=False, zeroline=False, showticklabels=False, linecolor='black', mirror=True, linewidth=1),\n                    width=800, height=600)\n                )\n\noutfile = Path(\"assets/figures/integrated_network.html\")\noutfile.parent.mkdir(parents=True, exist_ok=True)\nfig.write_html(outfile)\n\ndisplay(HTML(filename=str(outfile)))\n```\n</code></pre>"},{"location":"custom_tutorial/#adding-adjacency-edge","title":"Adding adjacency edge","text":"<p>If you have a high quality (complete) genomes, it might be interesting to see the position of each BGC regions relative to each other in a genome. Unfortunately, there are limited physics-based layout algorithm in python, so it is better to use Cytoscape or Gephi to visualize the network</p> <p>??? code \"Code\"     ```python     antismash_table = report_dir / f\"tables/df_regions_antismash_{antismash_version}.csv\"     df_antismash = pd.read_csv(antismash_table)</p> <pre><code># Create a new graph\nfiltered_graph = nx.Graph()\n\n# Iterate over the nodes in the original graph\nfor node, data in G.nodes(data=True):\n    # If the node meets the condition, add it to the new graph\n    if data.get('node_trace') == 'BGC':\n        filtered_graph.add_node(node, **data)\n\n# Now add only the edges that connect the nodes in the new graph\nfor u, v, data in G.edges(data=True):\n    if filtered_graph.has_node(u) and filtered_graph.has_node(v):\n        filtered_graph.add_edge(u, v, **data)\n\nfor i in df_antismash.index:\n    current_bgc = df_antismash.loc[i].to_dict()\n    next_index = i + 1\n    if next_index &lt; len(df_antismash):\n        neighbor_bgc = df_antismash.loc[next_index].to_dict()\n        if current_bgc[\"accession\"] == neighbor_bgc[\"accession\"]:\n            distance = neighbor_bgc[\"start_pos\"] - current_bgc[\"end_pos\"]\n            assert distance &gt; 0\n            if not filtered_graph.has_edge(current_bgc[\"bgc_id\"], neighbor_bgc[\"bgc_id\"]):\n                filtered_graph.add_edge(current_bgc[\"bgc_id\"], neighbor_bgc[\"bgc_id\"], distance_bp=distance, relation_type=\"genomic_adjacency\")\n\ndisplay(Markdown(get_graph_stats(filtered_graph, \"integrated_graph_with_adjacency\")))\n```\n</code></pre> <ul> <li>integrated_graph_with_adjacency : 739 total nodes (739 BGC nodes), 1598 edges, 4.32 average degree</li> </ul> <p>??? code \"Code\"     ```python     # Get self-loops     self_loops = nx.selfloop_edges(filtered_graph)</p> <pre><code># Check if there are any self-loops\nif self_loops is not None:\n    # Remove self-loops\n    filtered_graph.remove_edges_from(self_loops)\n\n# Iterate over the nodes of the graph, getting the node and its attributes\nfor n, data in filtered_graph.nodes(data=True):\n    # Create a list of keys to remove after iterating over the dictionary\n    keys_to_remove = []\n    # Iterate over the items in the attributes dictionary\n    for k, v in data.items():\n        # Check if the value is not of a type compatible with GraphML\n        if isinstance(v, (list, tuple)):\n            data[k] = \", \".join([str(i) for i in v])\n        elif v is None:\n            # Add the key to the list of keys to remove\n            keys_to_remove.append(k)\n        elif not isinstance(v, (int, float, str, bool, np.int64)):\n            print(f\"Node {n} has attribute {k} of incompatible type {type(v)}\")\n    # Remove the keys with None values\n    for key in keys_to_remove:\n        del filtered_graph.nodes[n][key]\n\noutfile = Path(f\"assets/data/bigscape_{bigscape_cutoff}_as{antismash_version}_with_genomic_position.graphml\")\noutfile.parent.mkdir(parents=True, exist_ok=True)\nnx.write_graphml(filtered_graph, outfile)\ndisplay(Markdown(f\"[Download Graph]({str(outfile)})\"+'{:target=\"_blank\" .md-button}'))\n```\n</code></pre> <p>Download Graph</p>"},{"location":"custom_tutorial/#displaying-the-notebook-in-the-report","title":"Displaying the notebook in the report","text":"<p>To display this notebook in the HTML report, we need to convert this notebook into a Markdown file.</p> <p>First, we need to serve BGCFlow report this command:</p> <pre><code>bgcflow serve --project &lt;project name&gt;\n</code></pre> <p>The report will be served locally in http://localhost:8001/</p> <p>Then, to generate the Markdown use NBConvert in the terminal:</p> <pre><code># cd to the docs folder containing this notebook\njupyter nbconvert --to markdown \\\n    --execute \"custom_tutorial.ipynb\" \\\n    --output \"custom_tutorial.md\" \\\n    --template \"admonition\" \\\n    --TemplateExporter.extra_template_basedirs=\"../../../../workflow/notebook/nb_convert\"\n</code></pre> <p>You can also use the <code>--no-input</code> flag if you don't want to show the code cells.</p> <p>Then, add the Markdown file to the <code>mkdocs.yaml</code> navigation:</p> <pre><code>extra:\n  social:\n  - icon: fontawesome/brands/twitter\n    link: https://twitter.com/NPGMgroup\n  - icon: fontawesome/brands/github\n    link: https://github.com/NBChub/bgcflow\nmarkdown_extensions:\n- attr_list\n- admonition\n- pymdownx.details\n- pymdownx.superfences\nnav:\n- Home: index.md\n- QC and Data Selection:\n  - seqfu: seqfu.md\n  - mash: mash.md\n  - fastani: fastani.md\n  - checkm: checkm.md\n- Functional Annotation:\n  - prokka-gbk: prokka-gbk.md\n  - deeptfactor: deeptfactor.md\n- Genome Mining:\n  - antismash: antismash.md\n  - query-bigslice: query-bigslice.md\n  - bigscape: bigscape.md\n  - bigslice: bigslice.md\n  - arts: arts.md\n  - cblaster-genome: cblaster-genome.md\n  - cblaster-bgc: cblaster-bgc.md\n- Phylogenomic Placement:\n  - automlst-wrapper: automlst-wrapper.md\n- Comparative Genomics:\n  - roary: roary.md\n  - eggnog-roary: eggnog-roary.md\n- Custom Reports:\n  - How to Add Custom Analysis to the BGCFlow Report: custom_tutorial.md\ntheme:\n  icon:\n    admonition:\n      note: octicons/tag-16\n      code: material/code-tags\n...\n</code></pre> <p>Once you updated the <code>mkdocs.yaml</code> file, the site will be regenerated to show your newly added report. The report can be opened here http://localhost:8001/custom_tutorial/</p>"},{"location":"deeptfactor/","title":"DeepTFactor","text":""},{"location":"deeptfactor/#deeptfactor","title":"DeepTFactor\u00b6","text":"<p>Summary of DeepTFactor results from project: <code>[{{ project().name }}]</code></p>"},{"location":"deeptfactor/#description","title":"Description\u00b6","text":"<p>A deep learning-based tool for the prediction of transcription factors.</p>"},{"location":"deeptfactor/#references","title":"References\u00b6","text":"<p>{% for i in project().rule_used['deeptfactor']['references'] %}</p> <ul> <li>{{ i }} {% endfor %}</li> </ul>"},{"location":"deeptfactor/","title":"DeepTFactor","text":"<p>Summary of DeepTFactor results from project: <code>[mq_saccharopolyspora]</code> </p>"},{"location":"deeptfactor/#description","title":"Description","text":"<p>A deep learning-based tool for the prediction of transcription factors.</p> locus_tag deeptfactor_prediction deeptfactor_score annotation genome_id Loading... (need help?)"},{"location":"deeptfactor/#references","title":"References","text":"<p> <ul> <li>Kim G.B., Gao Y., Palsson B.O., Lee S.Y. 2020. DeepTFactor: A deep learning-based tool for the prediction of transcription factors. PNAS. doi: 10.1073/pnas.2021171118</li> </ul> <p></p>"},{"location":"eggnog-roary/","title":"eggNOG-Roary","text":""},{"location":"eggnog-roary/#eggnog-roary","title":"eggNOG-Roary\u00b6","text":"<p>Summary of eggNOG-Roary results from project: <code>[{{ project().name }}]</code></p>"},{"location":"eggnog-roary/#description","title":"Description\u00b6","text":"<p>This report summarizes the functional annotation of Roary results using the eggNOG mapper. The eggNOG mapper provides functional annotation to genes based on the eggNOG database, which includes information on orthologous groups, functional descriptions, and additional metabolic and pathway data.</p>"},{"location":"eggnog-roary/#annotation-table","title":"Annotation Table\u00b6","text":""},{"location":"eggnog-roary/#cog-category-distribution","title":"COG Category Distribution\u00b6","text":""},{"location":"eggnog-roary/#core-pangene","title":"Core Pangene\u00b6","text":""},{"location":"eggnog-roary/#accessory-pangene","title":"Accessory Pangene\u00b6","text":""},{"location":"eggnog-roary/#rare-pangene","title":"Rare Pangene\u00b6","text":""},{"location":"eggnog-roary/#cog-categories","title":"COG Categories\u00b6","text":""},{"location":"eggnog-roary/#references","title":"References\u00b6","text":"<p>{% for i in project().rule_used['eggnog-roary']['references'] %}</p> <ul> <li>{{ i }} {% endfor %}</li> </ul>"},{"location":"eggnog-roary/","title":"eggNOG-Roary","text":"<p>Summary of eggNOG-Roary results from project: <code>[mq_saccharopolyspora]</code> </p>"},{"location":"eggnog-roary/#description","title":"Description","text":"<p>This report summarizes the functional annotation of Roary results using the eggNOG mapper. The eggNOG mapper provides functional annotation to genes based on the eggNOG database, which includes information on orthologous groups, functional descriptions, and additional metabolic and pathway data.</p>"},{"location":"eggnog-roary/#annotation-table","title":"Annotation Table","text":"locus_tag seed_ortholog evalue score max_annot_lvl COG_category Description Preferred_name EC KEGG_ko KEGG_Pathway KEGG_Module KEGG_Reaction KEGG_rclass BRITE KEGG_TC CAZy BiGG_Reaction PFAMs Loading... (need help?)"},{"location":"eggnog-roary/#cog-category-distribution","title":"COG Category Distribution","text":""},{"location":"eggnog-roary/#core-pangene","title":"Core Pangene","text":""},{"location":"eggnog-roary/#accessory-pangene","title":"Accessory Pangene","text":""},{"location":"eggnog-roary/#rare-pangene","title":"Rare Pangene","text":""},{"location":"eggnog-roary/#cog-categories","title":"COG Categories","text":"<p>A: RNA processing and modification | B: Chromatin structure and dynamics | C: Energy production and conversion | D: Cell cycle control, cell division, chromosome partitioning | E: Amino acid transport and metabolism | F: Nucleotide transport and metabolism | G: Carbohydrate transport and metabolism | H: Coenzyme transport and metabolism | I: Lipid transport and metabolism | J: Translation, ribosomal structure and biogenesis | K: Transcription | L: Replication, recombination and repair | M: Cell wall/membrane/envelope biogenesis | N: Cell motility | O: Post-translational modification, protein turnover, and chaperones | P: Inorganic ion transport and metabolism | Q: Secondary metabolites biosynthesis, transport, and catabolism | R: General function prediction only | S: Function unknown | T: Signal transduction mechanisms | U: Intracellular trafficking, secretion, and vesicular transport | V: Defense mechanisms | W: Extracellular structures | X: Mobilome: prophages, transposons | Y: Nuclear structure | Z: Cytoskeleton | -: Not found in COG |</p>"},{"location":"eggnog-roary/#references","title":"References","text":"<p> <ul> <li> <p>Andrew J. Page, Carla A. Cummins, Martin Hunt, Vanessa K. Wong, Sandra Reuter, Matthew T. G. Holden, Maria Fookes, Daniel Falush, Jacqueline A. Keane, Julian Parkhill, 'Roary: Rapid large-scale prokaryote pan genome analysis', Bioinformatics, 2015;31(22):3691-3693 doi:10.1093/bioinformatics/btv421</p> </li> <li> <p>eggNOG-mapper v2: functional annotation, orthology assignments, and domain prediction at the metagenomic scale. Carlos P. Cantalapiedra, Ana Hernandez-Plaza, Ivica Letunic, Peer Bork, Jaime Huerta-Cepas. 2021. Molecular Biology and Evolution, msab293</p> </li> <li> <p>eggNOG 5.0: a hierarchical, functionally and phylogenetically annotated orthology resource based on 5090 organisms and 2502 viruses. Jaime Huerta-Cepas, Damian Szklarczyk, Davide Heller, Ana Hern\u00e1ndez-Plaza, Sofia K Forslund, Helen Cook, Daniel R Mende, Ivica Letunic, Thomas Rattei, Lars J Jensen, Christian von Mering, Peer Bork Nucleic Acids Res. 2019 Jan 8; 47(Database issue): D309\u2013D314. doi: 10.1093/nar/gky1085</p> </li> </ul> <p></p>"},{"location":"fastani/","title":"FastANI","text":""},{"location":"fastani/#fastani","title":"FastANI\u00b6","text":"<p>Summary of FastANI results from project: <code>[{{ project().name }}]</code></p>"},{"location":"fastani/#description","title":"Description\u00b6","text":"<p>Fast Whole-Genome Similarity (ANI) Estimation</p>"},{"location":"fastani/#hierarchical-clustering-based-on-ani-values","title":"Hierarchical Clustering based on ANI values\u00b6","text":""},{"location":"fastani/#estimate-number-of-clusters","title":"Estimate Number of Clusters\u00b6","text":""},{"location":"fastani/#ani-clustermap","title":"ANI Clustermap\u00b6","text":""},{"location":"fastani/#references","title":"References\u00b6","text":"<ul> <li>Herman Saffar, O. 2022. An Approach for Choosing Number of Clusters for K-Means. www.medium.com</li> </ul> <p>{% for i in project().rule_used['fastani']['references'] %}</p> <ul> <li>{{ i }} {% endfor %} </li></ul>"},{"location":"fastani/","title":"FastANI","text":"<p>Summary of FastANI results from project: <code>[mq_saccharopolyspora]</code></p>"},{"location":"fastani/#description","title":"Description","text":"<p>Fast Whole-Genome Similarity (ANI) Estimation</p>"},{"location":"fastani/#hierarchical-clustering-based-on-ani-values","title":"Hierarchical Clustering based on ANI values","text":""},{"location":"fastani/#estimate-number-of-clusters","title":"Estimate Number of Clusters","text":"<pre><code>Estimated number of clusters: 8\n</code></pre>"},{"location":"fastani/#ani-clustermap","title":"ANI Clustermap","text":"<pre><code>&lt;Figure size 640x480 with 0 Axes&gt;\n</code></pre>"},{"location":"fastani/#references","title":"References","text":"<p> <ul> <li> <p>Herman Saffar, O. 2022. An Approach for Choosing Number of Clusters for K-Means. www.medium.com</p> </li> <li> <p>Jain, C., Rodriguez-R, L.M., Phillippy, A.M. et al. High throughput ANI analysis of 90K prokaryotic genomes reveals clear species boundaries. Nat Commun 9, 5114 (2018). https://doi.org/10.1038/s41467-018-07641-9</p> </li> </ul> <p></p>"},{"location":"gecco/","title":"GECCO","text":""},{"location":"gecco/#gecco","title":"GECCO\u00b6","text":"<p>Summary of BGCs detected by GECCO in each genome for: <code>[{{ project().name }}]</code></p>"},{"location":"gecco/#description","title":"Description\u00b6","text":"<p>GECCO is a fast and scalable method for identifying putative novel Biosynthetic Gene Clusters (BGCs) in genomic and metagenomic data using Conditional Random Fields (CRFs).</p>"},{"location":"gecco/#gecco-summary-result","title":"GECCO Summary Result\u00b6","text":""},{"location":"gecco/#references","title":"References\u00b6","text":"{% for i in project().rule_used['gecco']['references'] %} - {{ i }}  {% endfor %}"},{"location":"gecco/","title":"GECCO","text":"<p>Summary of BGCs detected by GECCO in each genome for: <code>[mq_saccharopolyspora]</code></p>"},{"location":"gecco/#description","title":"Description","text":"<p>GECCO is a fast and scalable method for identifying putative novel Biosynthetic Gene Clusters (BGCs) in genomic and metagenomic data using Conditional Random Fields (CRFs).</p>"},{"location":"gecco/#gecco-summary-result","title":"GECCO Summary Result","text":"cluster_id genome_id average_p max_p type length probability_score Loading... (need help?)"},{"location":"gecco/#overlap-with-antismash-bgcs","title":"Overlap with antiSMASH BGCs","text":"cluster_id genome_id average_p max_p type length probability_score antismash_target overlap_length overlap_proportion is_overlapping Loading... (need help?)"},{"location":"gecco/#references","title":"References","text":"<p> <ul> <li>Accurate de novo identification of biosynthetic gene clusters with GECCO. Laura M Carroll, Martin Larralde, Jonas Simon Fleck, Ruby Ponnudurai, Alessio Milanese, Elisa Cappio Barazzone, Georg Zeller. bioRxiv 2021.05.03.442509; doi:10.1101/2021.05.03.442509 </li> </ul> <p></p>"},{"location":"mash/","title":"MASH","text":""},{"location":"mash/#mash","title":"MASH\u00b6","text":"<p>Summary of MASH results from project: <code>[{{ project().name }}]</code></p>"},{"location":"mash/#description","title":"Description\u00b6","text":"<p>Fast genome and metagenome distance estimation using MinHash</p>"},{"location":"mash/#hierarchical-clustering-based-on-mash-distances","title":"Hierarchical Clustering based on MASH distances\u00b6","text":""},{"location":"mash/#estimate-number-of-clusters","title":"Estimate Number of Clusters\u00b6","text":""},{"location":"mash/#mash-clustermap","title":"MASH Clustermap\u00b6","text":""},{"location":"mash/#references","title":"References\u00b6","text":"{% for i in project().rule_used['mash']['references'] %} - *{{ i }}* {% endfor %}"},{"location":"mash/","title":"MASH","text":"<p>Summary of MASH results from project: <code>[mq_saccharopolyspora]</code></p>"},{"location":"mash/#description","title":"Description","text":"<p>Fast genome and metagenome distance estimation using MinHash</p>"},{"location":"mash/#hierarchical-clustering-based-on-mash-distances","title":"Hierarchical Clustering based on MASH distances","text":""},{"location":"mash/#estimate-number-of-clusters","title":"Estimate Number of Clusters","text":"<pre><code>Estimated number of clusters: 8\n</code></pre>"},{"location":"mash/#mash-clustermap","title":"MASH Clustermap","text":"<pre><code>&lt;Figure size 640x480 with 0 Axes&gt;\n</code></pre>"},{"location":"mash/#references","title":"References","text":"<p> <ul> <li> <p>Mash: fast genome and metagenome distance estimation using MinHash. Ondov BD, Treangen TJ, Melsted P, Mallonee AB, Bergman NH, Koren S, Phillippy AM. Genome Biol. 2016 Jun 20;17(1):132. doi: 10.1186/s13059-016-0997-x.</p> </li> <li> <p>Mash Screen: high-throughput sequence containment estimation for genome discovery. Ondov BD, Starrett GJ, Sappington A, Kostic A, Koren S, Buck CB, Phillippy AM. Genome Biol. 2019 Nov 5;20(1):232. doi: 10.1186/s13059-019-1841-x.</p> </li> </ul> <p></p>"},{"location":"prokka-gbk/","title":"Annotated genomes","text":""},{"location":"prokka-gbk/#annotated-genomes","title":"Annotated genomes\u00b6","text":"<p>List of annotated genomes from: <code>[{{ project().name }}]</code></p>"},{"location":"prokka-gbk/#description","title":"Description\u00b6","text":"<p>Summary table of annotated genbank files from each genomes.</p>"},{"location":"prokka-gbk/#summary-statistics","title":"Summary Statistics\u00b6","text":""},{"location":"prokka-gbk/#references","title":"References\u00b6","text":"<p>{% for i in project().rule_used['prokka-gbk']['references'] %}</p> <ul> <li>{{ i }} {% endfor %}</li> </ul>"},{"location":"prokka-gbk/","title":"Annotated genomes","text":"<p>List of annotated genomes from: <code>[mq_saccharopolyspora]</code> </p>"},{"location":"prokka-gbk/#description","title":"Description","text":"<p>Summary table of annotated genbank files from each genomes.</p> contigs bases CDS rRNA repeat_region tRNA tmRNA gbk file CDS table Loading... (need help?)"},{"location":"prokka-gbk/#summary-statistics","title":"Summary Statistics","text":""},{"location":"prokka-gbk/#references","title":"References","text":"<p> <ul> <li>Seemann T. Prokka: rapid prokaryotic genome annotation. Bioinformatics 2014 Jul 15;30(14):2068-9. PMID:24642063</li> </ul> <p></p>"},{"location":"query-bigslice/","title":"BiG-FAM Query","text":""},{"location":"query-bigslice/#big-fam-query","title":"BiG-FAM Query\u00b6","text":"<p>Summary of BiG-FAM Query results from project: <code>[{{ project().name }}]</code></p>"},{"location":"query-bigslice/#description","title":"Description\u00b6","text":"<p>Query against 1.2 Million BGCs in the BiG-FAM database using BiG-SLICE</p>"},{"location":"query-bigslice/#summary-result","title":"Summary Result\u00b6","text":""},{"location":"query-bigslice/#distribution-of-the-assigned-genus-from-big-fam-model-hits","title":"Distribution of the assigned genus from BiG-FAM Model hits\u00b6","text":""},{"location":"query-bigslice/#diversity-and-member-size-of-big-fam-model-hits","title":"Diversity and Member Size of BiG-FAM model hits\u00b6","text":""},{"location":"query-bigslice/#network-of-big-fam-model-hits","title":"Network of BiG-FAM model hits\u00b6","text":""},{"location":"query-bigslice/#references","title":"References\u00b6","text":"{% for i in project().rule_used['query-bigslice']['references'] %}   - *{{ i }}* {% endfor %}"},{"location":"query-bigslice/","title":"BiG-FAM Query","text":"<p>Summary of BiG-FAM Query results from project: <code>[mq_saccharopolyspora]</code></p>"},{"location":"query-bigslice/#description","title":"Description","text":"<p>Query against 1.2 Million BGCs in the BiG-FAM database using BiG-SLICE</p>"},{"location":"query-bigslice/#summary-result","title":"Summary Result","text":""},{"location":"query-bigslice/#distribution-of-the-assigned-genus-from-big-fam-model-hits","title":"Distribution of the assigned genus from BiG-FAM Model hits","text":""},{"location":"query-bigslice/#diversity-and-member-size-of-big-fam-model-hits","title":"Diversity and Member Size of BiG-FAM model hits","text":""},{"location":"query-bigslice/#network-of-big-fam-model-hits","title":"Network of BiG-FAM model hits","text":""},{"location":"query-bigslice/#references","title":"References","text":"<p> <ul> <li> <p>Satria A Kautsar, Kai Blin, Simon Shaw, Tilmann Weber, Marnix H Medema, BiG-FAM: the biosynthetic gene cluster families database, Nucleic Acids Research, gkaa812, https://doi.org/10.1093/nar/gkaa812</p> </li> <li> <p>Satria A Kautsar, Justin J J van der Hooft, Dick de Ridder, Marnix H Medema, BiG-SLiCE: A highly scalable tool maps the diversity of 1.2 million biosynthetic gene clusters, GigaScience, Volume 10, Issue 1, January 2021, giaa154.</p> </li> </ul> <p></p>"},{"location":"roary/","title":"Roary","text":""},{"location":"roary/#roary","title":"Roary\u00b6","text":"<p>Summary of Roary results from project: <code>[{{ project().name }}]</code></p>"},{"location":"roary/#description","title":"Description\u00b6","text":"<p>Rapid large-scale prokaryote pan genome analysis.</p>"},{"location":"roary/#pangenome-statistics","title":"Pangenome Statistics\u00b6","text":""},{"location":"roary/#pangenome-distribution","title":"Pangenome Distribution\u00b6","text":""},{"location":"roary/#pangene-distribution-across-phylogenetic-tree","title":"Pangene Distribution across phylogenetic tree\u00b6","text":""},{"location":"roary/#pangene-tables","title":"Pangene Tables\u00b6","text":""},{"location":"roary/#core-genes","title":"Core Genes\u00b6","text":""},{"location":"roary/#shell-genes","title":"Shell Genes\u00b6","text":""},{"location":"roary/#references","title":"References\u00b6","text":"<p>{% for i in project().rule_used['roary']['references'] %}</p> <ul> <li>{{ i }} {% endfor %}</li> </ul>"},{"location":"roary/","title":"Roary","text":"<p>Summary of Roary results from project: <code>[mq_saccharopolyspora]</code> </p>"},{"location":"roary/#description","title":"Description","text":"<p>Rapid large-scale prokaryote pan genome analysis.</p>"},{"location":"roary/#pangenome-statistics","title":"Pangenome Statistics","text":""},{"location":"roary/#pangenome-distribution","title":"Pangenome Distribution","text":"Pangenome Category Description Counts Loading... (need help?)"},{"location":"roary/#pangene-distribution-across-phylogenetic-tree","title":"Pangene Distribution across phylogenetic tree","text":""},{"location":"roary/#pangene-tables","title":"Pangene Tables","text":""},{"location":"roary/#core-genes","title":"Core Genes","text":"Gene Non-unique Gene name Annotation No. isolates No. sequences Avg sequences per isolate Genome Fragment Order within Fragment Accessory Fragment Accessory Order with Fragment QC Min group size nuc Max group size nuc Avg group size nuc locus_tag pangenome_class Loading... (need help?)"},{"location":"roary/#shell-genes","title":"Shell Genes","text":"Gene Non-unique Gene name Annotation No. isolates No. sequences Avg sequences per isolate Genome Fragment Order within Fragment Accessory Fragment Accessory Order with Fragment QC Min group size nuc Max group size nuc Avg group size nuc locus_tag pangenome_class Loading... (need help?)"},{"location":"roary/#references","title":"References","text":"<p> <ul> <li>Andrew J. Page, Carla A. Cummins, Martin Hunt, Vanessa K. Wong, Sandra Reuter, Matthew T. G. Holden, Maria Fookes, Daniel Falush, Jacqueline A. Keane, Julian Parkhill, 'Roary: Rapid large-scale prokaryote pan genome analysis', Bioinformatics, 2015;31(22):3691-3693 doi:10.1093/bioinformatics/btv421</li> </ul> <p></p>"},{"location":"seqfu/","title":"SeqFu2","text":"Axis Description <code>#Seq</code> The number of sequences in the input file. <code>Total bp</code> The total number of base pairs in all sequences. <code>Avg</code> The average length of the sequences in base pairs. <code>N50</code>, <code>N75</code>, <code>N90</code> The length of the shortest sequence such that the sum of the lengths of all sequences equal to or greater than it is at least 50%, 75%, or 90% of the total length of all sequences. <code>auN</code> area under the Nx curve. <code>Min</code> The length of the shortest sequence in base pairs. <code>Max</code> The length of the longest sequence in base pairs. <p>These statistics can be useful for assessing the quality and characteristics of a set of sequences, such as a genome assembly or a set of reads.</p> <p>[Download Table]({{ project().file_server() }}/tables/df_seqfu_stats.csv){:target=\"_blank\" .md-button}</p>"},{"location":"seqfu/#seqfu2","title":"SeqFu2\u00b6","text":"<p>Summary of Seqfu results from project: <code>[{{ project().name }}]</code></p>"},{"location":"seqfu/#description","title":"Description\u00b6","text":"<p>Seqfu2 provides a sequence statistic overview of the genomes in the dataset.</p>"},{"location":"seqfu/#genome-statistics-overview","title":"Genome Statistics Overview\u00b6","text":""},{"location":"seqfu/#references","title":"References\u00b6","text":"{% for i in project().rule_used['seqfu']['references'] %} - *{{ i }}* {% endfor %}"},{"location":"seqfu/","title":"SeqFu2","text":"<p>Summary of Seqfu results from project: <code>[mq_saccharopolyspora]</code> </p>"},{"location":"seqfu/#description","title":"Description","text":"<p>Seqfu2 provides a sequence statistic overview of the genomes in the dataset.</p>"},{"location":"seqfu/#genome-statistics-overview","title":"Genome Statistics Overview","text":"Axis Description <code>#Seq</code> The number of sequences in the input file. <code>Total bp</code> The total number of base pairs in all sequences. <code>Avg</code> The average length of the sequences in base pairs. <code>N50</code>, <code>N75</code>, <code>N90</code> The length of the shortest sequence such that the sum of the lengths of all sequences equal to or greater than it is at least 50%, 75%, or 90% of the total length of all sequences. <code>auN</code> area under the Nx curve. <code>Min</code> The length of the shortest sequence in base pairs. <code>Max</code> The length of the longest sequence in base pairs. <p>These statistics can be useful for assessing the quality and characteristics of a set of sequences, such as a genome assembly or a set of reads.</p> <p>Download Table</p>"},{"location":"seqfu/#references","title":"References","text":"<p> <ul> <li>Telatin, A., Birolo, G., &amp; Fariselli, P. SeqFu [Computer software]. GITHUB: https://github.com/telatin/seqfu2</li> </ul> <p></p>"}]}